<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ASL Learning App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Fraunces:wght@600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        :root {
            --cream: #FDF8F3;
            --warm-white: #FFFBF7;
            --ink: #1A1714;
            --ink-light: #4A4540;
            --ink-muted: #8A857F;
            --coral: #E85D4C;
            --coral-light: #FFEBE8;
            --sage: #7CA982;
            --sage-light: #E8F2EA;
            --gold: #D4A84B;
            --gold-light: #FFF8E7;
            --shadow-soft: 0 4px 20px rgba(26, 23, 20, 0.06);
            --shadow-medium: 0 8px 40px rgba(26, 23, 20, 0.1);
            --radius-sm: 8px;
            --radius-md: 16px;
            --radius-lg: 24px;
        }
        
        body {
            font-family: 'DM Sans', -apple-system, sans-serif;
            background: var(--cream);
            min-height: 100vh;
            min-height: 100dvh;
            color: var(--ink);
            line-height: 1.5;
        }
        
        .app-container {
            max-width: 480px;
            margin: 0 auto;
            padding: 0 16px 100px;
        }
        
        /* Header */
        .header {
            padding: 24px 0 20px;
            text-align: center;
            position: sticky;
            top: 0;
            background: var(--cream);
            z-index: 100;
        }
        
        .logo {
            font-family: 'Fraunces', serif;
            font-size: 28px;
            font-weight: 800;
            color: var(--ink);
            letter-spacing: -0.02em;
        }
        
        .logo span { color: var(--coral); }
        
        .tagline {
            font-size: 13px;
            color: var(--ink-muted);
            margin-top: 4px;
        }
        
        /* Mode Navigation */
        .mode-nav {
            display: flex;
            gap: 8px;
            padding: 4px;
            background: var(--warm-white);
            border-radius: var(--radius-lg);
            margin-bottom: 24px;
            box-shadow: var(--shadow-soft);
        }
        
        .mode-tab {
            flex: 1;
            padding: 14px 8px;
            border: none;
            background: transparent;
            border-radius: 20px;
            font-family: 'DM Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--ink-muted);
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .mode-tab .icon {
            font-size: 20px;
            transition: transform 0.25s ease;
        }
        
        .mode-tab.active {
            background: var(--ink);
            color: white;
        }
        
        .mode-tab.active .icon {
            transform: scale(1.1);
        }
        
        /* Content Panels */
        .panel {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .panel.active { display: block; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Cards */
        .card {
            background: var(--warm-white);
            border-radius: var(--radius-lg);
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: var(--shadow-soft);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .card-title {
            font-family: 'Fraunces', serif;
            font-size: 20px;
            font-weight: 700;
            color: var(--ink);
        }
        
        .badge {
            font-size: 11px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .badge-coral { background: var(--coral-light); color: var(--coral); }
        .badge-sage { background: var(--sage-light); color: var(--sage); }
        .badge-gold { background: var(--gold-light); color: var(--gold); }
        
        /* Sign Display */
        .sign-display {
            background: white;
            border-radius: var(--radius-md);
            padding: 20px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .sign-image {
            width: 288px;
            height: 288px;
            object-fit: cover;
            object-position: center 25%;
            margin: 0 auto 12px;
            filter: contrast(1.1);
            /* Crop to hide text that may appear in image */
            clip-path: inset(0 0 12% 0);
        }
        
        .sign-letter {
            font-family: 'Fraunces', serif;
            font-size: 48px;
            font-weight: 800;
            color: var(--ink);
            line-height: 1;
        }
        
        .sign-desc {
            font-size: 14px;
            color: var(--ink-muted);
            margin-top: 8px;
        }
        
        /* Progress Bar */
        .progress-container {
            margin-bottom: 20px;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--ink-muted);
            margin-bottom: 8px;
        }
        
        .progress-track {
            height: 6px;
            background: #E8E4E0;
            border-radius: 100px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--coral) 0%, var(--gold) 100%);
            border-radius: 100px;
            transition: width 0.4s ease;
        }
        
        /* Steps List */
        .steps-list {
            list-style: none;
        }
        
        .step-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 0;
            border-bottom: 1px solid #F0EBE6;
        }
        
        .step-item:last-child { border-bottom: none; }
        
        .step-num {
            width: 28px;
            height: 28px;
            background: var(--coral-light);
            color: var(--coral);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            flex-shrink: 0;
        }
        
        .step-text {
            font-size: 15px;
            color: var(--ink-light);
            padding-top: 3px;
        }
        
        /* Navigation Buttons */
        .nav-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        .btn {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-family: 'DM Sans', sans-serif;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: var(--ink);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--ink-light);
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: white;
            color: var(--ink);
            border: 2px solid #E8E4E0;
        }
        
        .btn-secondary:hover {
            border-color: var(--ink);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-camera {
            background: var(--coral);
            color: white;
        }
        
        .btn-camera:hover {
            background: #D14D3D;
        }
        
        .btn-camera.active {
            background: var(--ink-muted);
        }
        
        /* Camera Container */
        .camera-wrapper {
            position: relative;
            border-radius: var(--radius-lg);
            overflow: hidden;
            background: var(--ink);
            margin-bottom: 16px;
            aspect-ratio: 4/3;
        }
        
        .camera-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
        }
        
        .camera-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1);
        }
        
        .camera-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            opacity: 0.6;
        }
        
        .camera-placeholder .icon {
            font-size: 48px;
            margin-bottom: 12px;
        }
        
        /* Stats Row */
        .stats-row {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .stat-card {
            flex: 1;
            background: white;
            border-radius: var(--radius-md);
            padding: 16px;
            text-align: center;
        }
        
        .stat-value {
            font-family: 'Fraunces', serif;
            font-size: 32px;
            font-weight: 700;
            color: var(--ink);
        }
        
        .stat-value.success { color: var(--sage); }
        
        .stat-label {
            font-size: 12px;
            color: var(--ink-muted);
            margin-top: 4px;
        }
        
        /* Feedback Banner */
        .feedback-banner {
            padding: 16px 20px;
            border-radius: var(--radius-md);
            text-align: center;
            font-weight: 600;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }
        
        .feedback-banner.waiting {
            background: var(--gold-light);
            color: var(--gold);
        }
        
        .feedback-banner.success {
            background: var(--sage-light);
            color: var(--sage);
        }
        
        .feedback-banner.prompt {
            background: var(--coral-light);
            color: var(--coral);
        }
        
        /* Sign Grid */
        .sign-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        
        .sign-tile {
            aspect-ratio: 1;
            background: white;
            border-radius: var(--radius-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            padding: 4px;
        }
        
        .sign-tile:hover {
            border-color: var(--ink-muted);
            transform: translateY(-2px);
        }
        
        .sign-tile.active {
            border-color: var(--coral);
            background: var(--coral-light);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(232, 93, 76, 0.3);
        }
        
        /* Selected Sign Preview Card */
        .selected-sign-card {
            background: linear-gradient(135deg, var(--coral-light) 0%, var(--warm-white) 100%);
            border: 3px solid var(--coral);
            margin-bottom: 16px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .sign-tile img {
            width: 100%;
            height: 70%;
            object-fit: cover;
            object-position: center 30%;
            /* Crop to hide text that may appear in image */
            clip-path: inset(0 0 15% 0);
        }
        
        .sign-tile-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--ink);
            margin-top: 2px;
        }

        /* Vocabulary Tiles (for words without hand images) */
        .vocab-tile {
            min-height: 80px;
        }

        .vocab-icon {
            font-size: 28px;
            line-height: 1;
        }

        .vocab-tile .sign-tile-label {
            font-size: 10px;
            text-align: center;
            word-wrap: break-word;
            max-width: 100%;
        }

        /* Camera Info Box */
        .camera-info-box {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            background: linear-gradient(135deg, #E8F4FD 0%, #F0F7FF 100%);
            border: 1px solid #B8D4E8;
            border-left: 4px solid #4A90D9;
            border-radius: var(--radius-md);
            padding: 14px 16px;
            margin-bottom: 16px;
        }

        .camera-info-icon {
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .camera-info-text {
            font-size: 13px;
            color: var(--ink-light);
            line-height: 1.5;
        }

        .camera-info-text strong {
            display: block;
            font-size: 14px;
            color: var(--ink);
            margin-bottom: 4px;
        }

        .camera-info-text p {
            margin: 0;
        }

        /* Performance Toggle */
        .performance-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--warm-white);
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: var(--radius-md);
            padding: 12px 16px;
            margin-bottom: 16px;
        }

        .performance-toggle-label {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .performance-toggle-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--ink);
        }

        .performance-toggle-desc {
            font-size: 11px;
            color: var(--ink-muted);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--coral);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        /* Section Dividers */
        .section-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--ink-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 20px 0 12px;
        }
        
        /* Quiz Prompt */
        .quiz-prompt {
            text-align: center;
            padding: 24px;
        }
        
        .quiz-prompt-text {
            font-size: 14px;
            color: var(--ink-muted);
            margin-bottom: 8px;
        }
        
        .quiz-prompt-sign {
            font-family: 'Fraunces', serif;
            font-size: 64px;
            font-weight: 800;
            color: var(--ink);
        }
        
        .quiz-prompt-image {
            width: 216px;
            height: 216px;
            object-fit: contain;
            margin: 16px auto;
        }
        
        /* Mobile optimizations */
        @media (max-width: 400px) {
            .sign-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .sign-letter {
                font-size: 36px;
            }
            
            .sign-image {
                width: 216px;
                height: 216px;
            }
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
        
        /* Hide scrollbar but keep functionality */
        body::-webkit-scrollbar {
            width: 0;
        }

        /* Translate Mode Styles */
        .current-sign-overlay {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Fraunces', serif;
            font-size: 28px;
            font-weight: 800;
            color: var(--ink);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .current-sign-overlay.active {
            opacity: 1;
        }
        
        .confirm-ring {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 58px;
            height: 58px;
            transform: rotate(-90deg);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .confirm-ring.active {
            opacity: 1;
        }
        
        .confirm-ring-bg {
            fill: none;
            stroke: rgba(255,255,255,0.3);
            stroke-width: 4;
        }
        
        .confirm-ring-progress {
            fill: none;
            stroke: var(--sage);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 163.36;
            stroke-dashoffset: 163.36;
            transition: stroke-dashoffset 0.1s linear;
        }
        
        .translation-output-card {
            background: var(--warm-white);
        }
        
        .translation-output {
            min-height: 80px;
            padding: 16px;
            background: white;
            border-radius: var(--radius-md);
            font-size: 24px;
            font-weight: 600;
            color: var(--ink);
            word-wrap: break-word;
            margin-bottom: 16px;
            border: 2px solid #F0EBE6;
        }
        
        .translation-output .placeholder-text {
            color: var(--ink-muted);
            font-size: 16px;
            font-weight: 400;
            font-style: italic;
        }
        
        .translation-output .cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: var(--coral);
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: text-bottom;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .translation-actions {
            display: flex;
            gap: 8px;
        }
        
        .translation-actions .btn {
            flex: 1;
            padding: 12px 8px;
            font-size: 13px;
        }
        
        .btn-icon {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .btn-icon:hover {
            background: #F0EBE6;
        }
        
        #translateReference {
            grid-template-columns: repeat(6, 1fr);
        }
        
        #translateReference .sign-tile {
            padding: 8px;
            aspect-ratio: auto;
            min-height: 80px;
        }
        
        #translateReference .sign-tile img {
            height: 55px;
            width: auto;
            object-fit: cover;
            object-position: center 30%;
            clip-path: inset(0 0 15% 0);
        }
        
        #translateReference .sign-tile-label {
            font-size: 12px;
            font-weight: 600;
            margin-top: 4px;
        }
        
        /* Detected letter flash */
        .letter-confirmed {
            animation: letterPop 0.3s ease;
        }
        
        @keyframes letterPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: var(--sage-light); }
            100% { transform: scale(1); }
        }
    
        /* Phrases Mode Styles */
        .phrase-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .phrase-tile {
            background: white;
            border-radius: var(--radius-md);
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .phrase-tile:hover {
            border-color: var(--ink-muted);
            transform: translateY(-2px);
        }
        
        .phrase-tile.active {
            border-color: var(--sage);
            background: var(--sage-light);
        }
        
        .phrase-tile-text {
            font-weight: 600;
            color: var(--ink);
        }
        
        .phrase-tile-asl {
            font-size: 12px;
            color: var(--ink-muted);
        }
        
        /* Emergency section styling */
        #emergencyGrid .phrase-tile {
            background: #FFF5F5;
            border-color: #FFCDD2;
        }
        
        #emergencyGrid .phrase-tile:hover {
            border-color: var(--coral);
        }
        
        #emergencyGrid .phrase-tile .phrase-tile-text {
            color: var(--coral);
        }
        
        .phrase-letter-card {
            background: white;
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: center;
            min-width: 70px;
            box-shadow: var(--shadow-soft);
        }
        
        .phrase-letter-card img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }
        
        .phrase-letter-card .letter-label {
            font-family: 'Fraunces', serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--ink);
            margin-top: 4px;
        }
        
        .badge-sage {
            background: var(--sage-light);
            color: var(--sage);
        }

        /* Disclaimer */
        .disclaimer {
            margin-top: 40px;
            padding: 20px;
            background: var(--warm-white);
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: var(--radius-md);
            text-align: center;
        }

        .disclaimer-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--ink);
            margin-bottom: 8px;
        }

        .disclaimer-text {
            font-size: 12px;
            color: var(--ink-muted);
            line-height: 1.6;
        }

    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1 class="logo">ASL<span>Learn</span></h1>
            <p class="tagline">Master the American Sign Language alphabet</p>
        </header>
        
        <nav class="mode-nav">
            <button class="mode-tab active" data-mode="learn">
                <span class="icon">üìö</span>
                <span>Learn</span>
            </button>
            <button class="mode-tab" data-mode="test">
                <span class="icon">‚úèÔ∏è</span>
                <span>Test</span>
            </button>
            <button class="mode-tab" data-mode="practice">
                <span class="icon">üí™</span>
                <span>Practice</span>
            </button>
            <button class="mode-tab" data-mode="phrases">
                <span class="icon">üí¨</span>
                <span>Phrases</span>
            </button>
        </nav>
        
        <!-- LEARN MODE -->
        <section id="learnPanel" class="panel active">
            <div class="progress-container">
                <div class="progress-label">
                    <span>Progress</span>
                    <span id="progressText">1 of 36</span>
                </div>
                <div class="progress-track">
                    <div class="progress-fill" id="progressBar" style="width: 2.8%"></div>
                </div>
            </div>
            
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title" id="lessonTitle">Letter A</h2>
                    <span class="badge badge-coral" id="lessonBadge">Alphabet</span>
                </div>
                
                <div class="sign-display">
                    <img id="lessonImage" class="sign-image" src="" alt="ASL Sign">
                    <div class="sign-letter" id="lessonLetter">A</div>
                    <p class="sign-desc" id="lessonDesc">Fist with thumb on the side</p>
                </div>
                
                <ul class="steps-list" id="lessonSteps"></ul>
            </div>
            
            <div class="nav-buttons">
                <button class="btn btn-secondary" id="prevBtn" disabled>
                    ‚Üê Back
                </button>
                <button class="btn btn-primary" id="nextBtn">
                    Next ‚Üí
                </button>
            </div>
        </section>
        
        <!-- TEST MODE -->
        <section id="testPanel" class="panel">
            <div class="stats-row">
                <div class="stat-card">
                    <div class="stat-value success" id="testCorrect">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="testTotal">0</div>
                    <div class="stat-label">Total</div>
                </div>
            </div>

            <!-- Camera Info Box -->
            <div class="camera-info-box">
                <span class="camera-info-icon">‚ÑπÔ∏è</span>
                <div class="camera-info-text">
                    <strong>Why enable camera?</strong>
                    <p>The camera uses hand-tracking technology to detect your hand positions and recognize the ASL signs you're making. Your video is processed locally and never stored or sent anywhere.</p>
                </div>
            </div>

            <!-- Body Skeleton Toggle -->
            <div class="performance-toggle">
                <div class="performance-toggle-label">
                    <span class="performance-toggle-title">Body Skeleton</span>
                    <span class="performance-toggle-desc">Enable for signs like Mother/Father (slower)</span>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="testSkeletonToggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="card">
                <div class="camera-wrapper">
                    <video id="testVideo" autoplay playsinline></video>
                    <canvas id="testCanvas"></canvas>
                    <div class="camera-placeholder" id="testPlaceholder">
                        <span class="icon">üì∑</span>
                        <span>Camera off</span>
                    </div>
                </div>

                <button class="btn btn-camera" id="testCameraBtn" style="width: 100%; margin-bottom: 16px;">
                    Start Camera
                </button>
                
                <div class="quiz-prompt">
                    <p class="quiz-prompt-text">Show the sign for:</p>
                    <img id="testPromptImage" class="quiz-prompt-image" src="" alt="Target sign">
                    <div class="quiz-prompt-sign" id="testPromptLetter">A</div>
                </div>
            </div>
            
            <div id="testFeedback" class="feedback-banner waiting">
                Make the sign shown above
            </div>
            
            <button class="btn btn-primary" id="skipBtn" style="width: 100%;">
                Skip ‚Üí
            </button>
        </section>
        
        <!-- PRACTICE MODE -->
        <section id="practicePanel" class="panel">
            <div class="stats-row">
                <div class="stat-card">
                    <div class="stat-value success" id="practiceCorrect">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="practiceAttempts">0</div>
                    <div class="stat-label">Attempts</div>
                </div>
            </div>

            <!-- Camera Info Box -->
            <div class="camera-info-box">
                <span class="camera-info-icon">‚ÑπÔ∏è</span>
                <div class="camera-info-text">
                    <strong>Why enable camera?</strong>
                    <p>The camera uses hand-tracking technology to detect your hand positions and recognize the ASL signs you're making. Your video is processed locally and never stored or sent anywhere.</p>
                </div>
            </div>

            <!-- Body Skeleton Toggle -->
            <div class="performance-toggle">
                <div class="performance-toggle-label">
                    <span class="performance-toggle-title">Body Skeleton</span>
                    <span class="performance-toggle-desc">Enable for signs like Mother/Father (slower)</span>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="practiceSkeletonToggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <div class="card">
                <div class="camera-wrapper">
                    <video id="practiceVideo" autoplay playsinline></video>
                    <canvas id="practiceCanvas"></canvas>
                    <div class="camera-placeholder" id="practicePlaceholder">
                        <span class="icon">üì∑</span>
                        <span>Camera off</span>
                    </div>
                </div>
                
                <button class="btn btn-camera" id="practiceCameraBtn" style="width: 100%;">
                    Start Camera
                </button>
            </div>
            
            <div id="practiceFeedback" class="feedback-banner waiting">
                Select a sign below to practice
            </div>
            
            <!-- Selected Sign Preview -->
            <div id="selectedSignPreview" class="card selected-sign-card" style="display: none;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <img id="selectedSignImage" src="" alt="Selected sign" style="width: 150px; height: 150px; object-fit: contain;">
                    <div style="flex: 1;">
                        <div style="font-family: 'Fraunces', serif; font-size: 48px; font-weight: 800; color: var(--ink);" id="selectedSignLetter">A</div>
                        <div style="font-size: 14px; color: var(--ink-muted);" id="selectedSignDesc">Fist with thumb on the side</div>
                    </div>
                </div>
            </div>
            
            <p class="section-label">Alphabet</p>
            <div class="sign-grid" id="alphabetGrid"></div>

            <p class="section-label">Numbers</p>
            <div class="sign-grid" id="numbersGrid"></div>

            <p class="section-label">Family</p>
            <div class="sign-grid" id="familyGrid"></div>

            <p class="section-label">Colors</p>
            <div class="sign-grid" id="colorsGrid"></div>

            <p class="section-label">Days of the Week</p>
            <div class="sign-grid" id="daysGrid"></div>

            <p class="section-label">Seasons</p>
            <div class="sign-grid" id="seasonsGrid"></div>

            <p class="section-label">Holidays</p>
            <div class="sign-grid" id="holidaysGrid"></div>
        </section>

        <!-- PHRASES MODE -->
        <section id="phrasesPanel" class="panel">
            <div class="card" style="margin-bottom: 16px; background: var(--sage-light); border-left: 4px solid var(--sage);">
                <p style="font-size: 14px; color: var(--ink-light); margin: 0;">
                    <strong>Learn common ASL phrases!</strong> Select a phrase below to learn how to sign it. Watch the video demo, then practice with your camera!
                </p>
            </div>
            
            <div class="card phrase-display-card" id="phraseDisplayCard" style="display: none;">
                <div class="card-header">
                    <h2 class="card-title" id="phraseTitle">Hello</h2>
                    <span class="badge badge-sage" id="phraseBadge">Greeting</span>
                </div>
                
                <div id="phraseDescription" style="font-size: 14px; color: var(--ink-muted); margin-bottom: 16px;">
                    A friendly greeting
                </div>
                
                <!-- Video Demo Section -->
                <div id="phraseVideoContainer" style="margin-bottom: 16px;">
                    <p class="section-label" style="margin-top: 0;">Watch the Sign</p>
                    <div id="phraseGifWrapper" style="width: 100%; max-width: 300px; margin: 0 auto; border-radius: var(--radius-md); overflow: hidden; background: #000;">
                        <div style="position: relative; padding-bottom: 100%; height: 0;">
                            <iframe id="phraseGif" src="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allowFullScreen></iframe>
                        </div>
                    </div>
                    <p id="noGifMessage" style="display: none; text-align: center; color: var(--ink-muted); font-size: 13px; padding: 20px;">
                        No video available for this phrase. See fingerspelling below.
                    </p>
                    <p style="text-align: center; font-size: 11px; color: var(--ink-muted); margin-top: 8px;">
                        Video: <a href="https://giphy.com/signwithrobert" target="_blank" style="color: var(--sage);">Sign with Robert via GIPHY</a>
                    </p>
                </div>
                
                <!-- Practice Camera Section -->
                <div style="margin-bottom: 16px;">
                    <p class="section-label" style="margin-top: 0;">Practice Along</p>
                    <div class="camera-wrapper" style="aspect-ratio: 4/3; max-width: 100%;">
                        <video id="phrasesVideo" autoplay playsinline></video>
                        <canvas id="phrasesCanvas"></canvas>
                        <div class="camera-placeholder" id="phrasesPlaceholder">
                            <span class="icon">üì∑</span>
                            <span>Camera off</span>
                        </div>
                    </div>
                    <button class="btn btn-camera" id="phrasesCameraBtn" style="width: 100%;">
                        Start Practice Camera
                    </button>
                </div>
                
                <!-- Fingerspelling Reference -->
                <div style="margin-bottom: 16px;">
                    <p class="section-label" style="margin-top: 0;">Fingerspelling</p>
                    <div id="phraseLettersContainer" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;">
                        <!-- Letter cards will be inserted here -->
                    </div>
                </div>
                
                <!-- How to Sign Steps -->
                <div id="phraseSteps" style="background: var(--gold-light); padding: 16px; border-radius: var(--radius-md);">
                    <strong style="color: var(--gold);">How to sign:</strong>
                    <ol id="phraseStepsList" style="margin: 8px 0 0 20px; color: var(--ink-light);"></ol>
                </div>
            </div>
            
            <p class="section-label">Greetings & Basics</p>
            <div class="phrase-grid" id="greetingsGrid"></div>
            
            <p class="section-label">Questions</p>
            <div class="phrase-grid" id="questionsGrid"></div>
            
            <p class="section-label">Feelings & States</p>
            <div class="phrase-grid" id="feelingsGrid"></div>
            
            <p class="section-label">Everyday Needs</p>
            <div class="phrase-grid" id="needsGrid"></div>
            
            <p class="section-label">About Me</p>
            <div class="phrase-grid" id="aboutmeGrid"></div>
            
            <p class="section-label">Small Talk & Weather</p>
            <div class="phrase-grid" id="smalltalkGrid"></div>
            
            <p class="section-label">Pets & Animals</p>
            <div class="phrase-grid" id="petsGrid"></div>
            
            <p class="section-label">Emergency</p>
            <div class="phrase-grid" id="emergencyGrid"></div>
        </section>

        <!-- Disclaimer -->
        <div class="disclaimer">
            <div class="disclaimer-title">Disclaimer</div>
            <div class="disclaimer-text">
                This app was created to the best of my ability as a learning tool. Please verify all signs with qualified ASL resources, as accuracy may vary. All data is processed and stored locally on your device - nothing is uploaded or stored on external servers. Your privacy is fully protected.
            </div>
        </div>
    </div>

    <script>
        // ASL Images data (base64 encoded)
        const ASL_IMAGES = {
            "0": "images/0.png", "1": "images/1.png", "2": "images/2.png",
            "3": "images/3.png", "4": "images/4.png", "5": "images/5.png",
            "6": "images/6.png", "7": "images/7.png", "8": "images/8.png",
            "9": "images/9.png", "a": "images/a.png", "b": "images/b.png",
            "c": "images/c.png", "d": "images/d.png", "e": "images/e.png",
            "f": "images/f.png", "g": "images/g.png", "h": "images/h.png",
            "i": "images/i.png", "j": "images/j.png", "k": "images/k.png",
            "l": "images/l.png", "m": "images/m.png", "n": "images/n.png",
            "o": "images/o.png", "p": "images/p.png", "q": "images/q.png",
            "r": "images/r.png", "s": "images/s.png", "t": "images/t.png",
            "u": "images/u.png", "v": "images/v.png", "w": "images/w.png",
            "x": "images/x.png", "y": "images/y.png", "z": "images/z.png"
        };
        
        // Sign definitions with detection patterns
        const SIGNS = [
            // Alphabet
            {id: 'a', name: 'A', type: 'letter', desc: 'Fist with thumb on the side', steps: ['Make a fist', 'Place thumb against side of fist', 'Palm faces forward']},
            {id: 'b', name: 'B', type: 'letter', desc: 'Flat hand, fingers together, thumb tucked', steps: ['Extend all four fingers up', 'Keep fingers together', 'Tuck thumb across palm']},
            {id: 'c', name: 'C', type: 'letter', desc: 'Curved hand like letter C', steps: ['Curve fingers and thumb', 'Form a C shape', 'Palm faces sideways']},
            {id: 'd', name: 'D', type: 'letter', desc: 'Index up, others touch thumb', steps: ['Extend index finger up', 'Touch middle, ring, pinky to thumb', 'Forms a D shape']},
            {id: 'e', name: 'E', type: 'letter', desc: 'Fingers curled, thumb tucked', steps: ['Curl all fingers down', 'Tuck thumb under fingers', 'Like a claw shape']},
            {id: 'f', name: 'F', type: 'letter', desc: 'Index and thumb touch, others up', steps: ['Touch index to thumb tip', 'Extend middle, ring, pinky up', 'Forms an OK shape']},
            {id: 'g', name: 'G', type: 'letter', desc: 'Index and thumb parallel, pointing', steps: ['Extend index finger sideways', 'Extend thumb parallel', 'Other fingers closed']},
            {id: 'h', name: 'H', type: 'letter', desc: 'Index and middle out horizontally', steps: ['Extend index and middle together', 'Point them sideways', 'Other fingers closed']},
            {id: 'i', name: 'I', type: 'letter', desc: 'Pinky extended up', steps: ['Make a fist', 'Extend only the pinky up', 'Palm faces forward']},
            {id: 'j', name: 'J', type: 'letter', desc: 'Pinky draws J in the air', steps: ['Start with I sign (pinky up)', 'Trace a J shape downward', 'Involves movement']},
            {id: 'k', name: 'K', type: 'letter', desc: 'Index and middle up, thumb between', steps: ['Extend index and middle in V', 'Place thumb between them', 'Other fingers closed']},
            {id: 'l', name: 'L', type: 'letter', desc: 'L-shape with index and thumb', steps: ['Extend index finger up', 'Extend thumb out to side', 'Forms an L shape']},
            {id: 'm', name: 'M', type: 'letter', desc: 'Three fingers over thumb', steps: ['Tuck thumb under', 'Drape index, middle, ring over thumb', 'Pinky tucked']},
            {id: 'n', name: 'N', type: 'letter', desc: 'Two fingers over thumb', steps: ['Tuck thumb under', 'Drape index and middle over thumb', 'Other fingers tucked']},
            {id: 'o', name: 'O', type: 'letter', desc: 'Fingers touch thumb forming O', steps: ['Curve all fingers', 'Touch fingertips to thumb tip', 'Forms an O shape']},
            {id: 'p', name: 'P', type: 'letter', desc: 'Like K but pointing down', steps: ['Form K handshape', 'Point hand downward', 'Index finger points out']},
            {id: 'q', name: 'Q', type: 'letter', desc: 'Like G but pointing down', steps: ['Form G handshape', 'Point hand downward', 'Index and thumb point down']},
            {id: 'r', name: 'R', type: 'letter', desc: 'Crossed index and middle', steps: ['Cross index over middle', 'Keep them extended', 'Other fingers closed']},
            {id: 's', name: 'S', type: 'letter', desc: 'Fist with thumb over fingers', steps: ['Make a fist', 'Wrap thumb over fingers', 'Palm faces forward']},
            {id: 't', name: 'T', type: 'letter', desc: 'Thumb between index and middle', steps: ['Make a fist', 'Tuck thumb between index and middle', 'Thumb tip may show']},
            {id: 'u', name: 'U', type: 'letter', desc: 'Index and middle up together', steps: ['Extend index and middle up', 'Keep them together', 'Other fingers closed']},
            {id: 'v', name: 'V', type: 'letter', desc: 'Index and middle in V shape', steps: ['Extend index and middle up', 'Spread them apart in V', 'Other fingers closed']},
            {id: 'w', name: 'W', type: 'letter', desc: 'Three fingers up spread', steps: ['Extend index, middle, ring up', 'Spread them apart', 'Thumb holds pinky']},
            {id: 'x', name: 'X', type: 'letter', desc: 'Index bent like a hook', steps: ['Extend index finger', 'Bend it at middle joint', 'Like a hook shape']},
            {id: 'y', name: 'Y', type: 'letter', desc: 'Thumb and pinky extended', steps: ['Extend thumb and pinky out', 'Close middle three fingers', '"Hang loose" gesture']},
            {id: 'z', name: 'Z', type: 'letter', desc: 'Index draws Z in the air', steps: ['Point index finger out', 'Draw a Z shape in the air', 'Involves movement']},
            // Numbers
            {id: '0', name: '0', type: 'number', desc: 'O handshape', steps: ['Same as letter O', 'Fingertips touch thumb', 'Forms a circle']},
            {id: '1', name: '1', type: 'number', desc: 'Index finger up', steps: ['Make a fist', 'Extend index finger up', 'Like pointing up']},
            {id: '2', name: '2', type: 'number', desc: 'Index and middle up in V', steps: ['Extend index and middle', 'Spread them in V shape', 'Like peace sign']},
            {id: '3', name: '3', type: 'number', desc: 'Thumb, index, middle extended', steps: ['Extend thumb out', 'Extend index and middle up', 'Ring and pinky closed']},
            {id: '4', name: '4', type: 'number', desc: 'Four fingers up, thumb tucked', steps: ['Extend all four fingers up', 'Spread them apart', 'Tuck thumb into palm']},
            {id: '5', name: '5', type: 'number', desc: 'All five digits spread', steps: ['Open hand completely', 'Spread all fingers', 'Include thumb extended']},
            {id: '6', name: '6', type: 'number', desc: 'Pinky touches thumb', steps: ['Extend middle, ring, index up', 'Touch pinky to thumb', 'Forms a circle below']},
            {id: '7', name: '7', type: 'number', desc: 'Ring finger touches thumb', steps: ['Extend index, middle, pinky up', 'Touch ring to thumb', 'Three fingers up']},
            {id: '8', name: '8', type: 'number', desc: 'Middle finger touches thumb', steps: ['Extend index, ring, pinky up', 'Touch middle to thumb', 'Three fingers up']},
            {id: '9', name: '9', type: 'number', desc: 'Index touches thumb', steps: ['Extend middle, ring, pinky up', 'Touch index to thumb', 'Like OK with fingers up']},

            // Family
            {id: 'mother', name: 'Mother', type: 'family', desc: 'Thumb on chin, open hand', steps: ['Open hand with fingers spread', 'Touch thumb to chin', 'Keep palm facing left']},
            {id: 'father', name: 'Father', type: 'family', desc: 'Thumb on forehead, open hand', steps: ['Open hand with fingers spread', 'Touch thumb to forehead', 'Keep palm facing left']},
            {id: 'sister', name: 'Sister', type: 'family', desc: 'A-hand from chin, then 1-hands together', steps: ['Start with A-hand at chin', 'Move down to index fingers together', 'Both hands point forward']},
            {id: 'brother', name: 'Brother', type: 'family', desc: 'A-hand from forehead, then 1-hands together', steps: ['Start with A-hand at forehead', 'Move down to index fingers together', 'Both hands point forward']},
            {id: 'baby', name: 'Baby', type: 'family', desc: 'Rock arms like holding baby', steps: ['Place one arm over the other', 'Rock arms side to side', 'Like cradling a baby']},
            {id: 'family', name: 'Family', type: 'family', desc: 'F-hands circle outward', steps: ['Both hands in F shape', 'Start together in front', 'Circle outward to meet again']},
            {id: 'grandmother', name: 'Grandmother', type: 'family', desc: 'Mother sign with two bounces forward', steps: ['Do the mother sign (thumb on chin)', 'Bounce hand forward twice', 'Shows generational distance']},
            {id: 'grandfather', name: 'Grandfather', type: 'family', desc: 'Father sign with two bounces forward', steps: ['Do the father sign (thumb on forehead)', 'Bounce hand forward twice', 'Shows generational distance']},

            // Colors
            {id: 'red', name: 'Red', type: 'color', desc: 'Index finger brushes down lips', steps: ['Point index finger', 'Touch to lips', 'Brush downward once or twice']},
            {id: 'blue', name: 'Blue', type: 'color', desc: 'B-hand shakes side to side', steps: ['Make B handshape', 'Shake hand side to side', 'Palm faces outward']},
            {id: 'green', name: 'Green', type: 'color', desc: 'G-hand shakes side to side', steps: ['Make G handshape', 'Shake hand side to side', 'Twist at wrist']},
            {id: 'yellow', name: 'Yellow', type: 'color', desc: 'Y-hand shakes side to side', steps: ['Make Y handshape (pinky and thumb out)', 'Shake hand side to side', 'Twist at wrist']},
            {id: 'orange', name: 'Orange', type: 'color', desc: 'S-hand squeezes at chin', steps: ['Make S handshape (fist)', 'Place near chin', 'Squeeze open and closed']},
            {id: 'purple', name: 'Purple', type: 'color', desc: 'P-hand shakes side to side', steps: ['Make P handshape', 'Shake hand side to side', 'Twist at wrist']},
            {id: 'black', name: 'Black', type: 'color', desc: 'Index finger draws across forehead', steps: ['Extend index finger', 'Draw across forehead', 'From one side to the other']},
            {id: 'white', name: 'White', type: 'color', desc: 'Open hand pulls from chest', steps: ['Place open hand on chest', 'Pull hand away', 'Close fingers as you pull']},
            {id: 'pink', name: 'Pink', type: 'color', desc: 'P-hand brushes down lips', steps: ['Make P handshape', 'Middle finger touches lips', 'Brush downward']},
            {id: 'brown', name: 'Brown', type: 'color', desc: 'B-hand slides down cheek', steps: ['Make B handshape', 'Place on cheek', 'Slide downward']},

            // Days of the Week
            {id: 'monday', name: 'Monday', type: 'day', desc: 'M-hand circles', steps: ['Make M handshape', 'Small circle motion', 'Palm faces you']},
            {id: 'tuesday', name: 'Tuesday', type: 'day', desc: 'T-hand circles', steps: ['Make T handshape', 'Small circle motion', 'Palm faces you']},
            {id: 'wednesday', name: 'Wednesday', type: 'day', desc: 'W-hand circles', steps: ['Make W handshape (3 fingers up)', 'Small circle motion', 'Palm faces you']},
            {id: 'thursday', name: 'Thursday', type: 'day', desc: 'H-hand circles (or TH)', steps: ['Make H handshape', 'Small circle motion', 'Some use T-H combination']},
            {id: 'friday', name: 'Friday', type: 'day', desc: 'F-hand circles', steps: ['Make F handshape', 'Small circle motion', 'Palm faces you']},
            {id: 'saturday', name: 'Saturday', type: 'day', desc: 'S-hand circles', steps: ['Make S handshape (fist)', 'Small circle motion', 'Palm faces you']},
            {id: 'sunday', name: 'Sunday', type: 'day', desc: 'Both open hands push outward', steps: ['Both hands open, palms out', 'Push outward and down', 'Peaceful, calm motion']},
            {id: 'today', name: 'Today', type: 'day', desc: 'Y-hands drop down', steps: ['Both hands in Y shape', 'Start at shoulder height', 'Drop down together']},
            {id: 'tomorrow', name: 'Tomorrow', type: 'day', desc: 'Thumb on cheek moves forward', steps: ['A-hand with thumb up', 'Touch thumb to cheek', 'Arc forward']},
            {id: 'yesterday', name: 'Yesterday', type: 'day', desc: 'Thumb touches cheek then chin', steps: ['A-hand or Y-hand', 'Touch thumb to cheek', 'Then touch to chin']},

            // Seasons
            {id: 'spring', name: 'Spring', type: 'season', desc: 'Hand pushes through other hand like plant growing', steps: ['Non-dominant hand in C shape', 'Dominant hand pushes up through', 'Like a plant sprouting']},
            {id: 'summer', name: 'Summer', type: 'season', desc: 'Index finger wipes across forehead', steps: ['Extend index finger', 'Draw across forehead', 'Like wiping sweat']},
            {id: 'fall', name: 'Fall/Autumn', type: 'season', desc: 'Flat hand brushes down forearm', steps: ['Hold non-dominant arm up', 'Brush dominant hand down arm', 'Like leaves falling']},
            {id: 'winter', name: 'Winter', type: 'season', desc: 'W-hands or fists shake (shivering)', steps: ['Both hands in W or S shape', 'Hold in front of body', 'Shake like shivering from cold']},
            {id: 'weather', name: 'Weather', type: 'season', desc: 'W-hands twist down', steps: ['Both hands in W shape', 'Start at top', 'Twist and move downward']},
            {id: 'hot', name: 'Hot', type: 'season', desc: 'Claw hand pulls away from mouth', steps: ['Claw hand at mouth', 'Pull away and turn', 'Like something too hot to eat']},
            {id: 'cold', name: 'Cold', type: 'season', desc: 'Fists shake near shoulders', steps: ['Both hands in fists', 'Hold near shoulders', 'Shake like shivering']},
            {id: 'rain', name: 'Rain', type: 'season', desc: 'Claw hands move down repeatedly', steps: ['Both hands in claw shape', 'Move down repeatedly', 'Like rain falling']},
            {id: 'snow', name: 'Snow', type: 'season', desc: 'Fingers wiggle while hands float down', steps: ['Open hands with spread fingers', 'Wiggle fingers', 'Float hands downward']},
            {id: 'sun', name: 'Sun', type: 'season', desc: 'C-hand at side of head opens', steps: ['C-hand near side of head', 'Open hand outward', 'Like rays of sun']},

            // Holidays
            {id: 'christmas', name: 'Christmas', type: 'holiday', desc: 'C-hand arcs from elbow', steps: ['Make C handshape', 'Place at elbow of other arm', 'Arc downward']},
            {id: 'thanksgiving', name: 'Thanksgiving', type: 'holiday', desc: 'Both hands at chin move forward', steps: ['Flat hands touch chin', 'Move outward and down', 'Like giving thanks']},
            {id: 'halloween', name: 'Halloween', type: 'holiday', desc: 'Both hands cover then reveal face', steps: ['Cover face with both hands', 'Pull away revealing face', 'Like peek-a-boo']},
            {id: 'birthday', name: 'Birthday', type: 'holiday', desc: 'Middle finger touches chin then chest', steps: ['Middle finger of open hand', 'Touch chin then chest', 'Some add BIRTH + DAY']},
            {id: 'holiday', name: 'Holiday', type: 'holiday', desc: 'Thumbs tap armpits twice', steps: ['Both hands in 5 shape', 'Thumbs tap armpits', 'Tap twice (relaxing)']},
            {id: 'newyear', name: 'New Year', type: 'holiday', desc: 'NEW + YEAR combination', steps: ['Sign NEW (scoop motion)', 'Then sign YEAR (fists circle)', 'Combine both signs']},
            {id: 'easter', name: 'Easter', type: 'holiday', desc: 'E-hands twist at wrists', steps: ['Both hands in E shape', 'Twist back and forth', 'At wrist level']},
            {id: 'valentine', name: 'Valentine', type: 'holiday', desc: 'Draw heart on chest', steps: ['Both middle fingers', 'Draw heart shape on chest', 'Start at top of heart']}
        ];

        // Common ASL Phrases (only phrases with GIF references)
        const PHRASES = [
            // ===== GREETINGS & BASICS =====
            { id: 'hello', text: 'Hello', category: 'greetings', letters: ['H', 'E', 'L', 'L', 'O'],
              description: 'A friendly greeting',
              gifId: '3o7TKNKOfKlIhbD3gY',
              steps: ['Wave your open hand side to side near your face', 'Or fingerspell H-E-L-L-O'] },
            { id: 'goodbye', text: 'Goodbye', category: 'greetings', letters: ['G', 'O', 'O', 'D', 'B', 'Y', 'E'],
              description: 'A farewell greeting',
              gifId: '3o7TKzb3i29i86BPJm',
              steps: ['Wave your hand back and forth', 'Like waving goodbye to someone'] },
            { id: 'thankyou', text: 'Thank You', category: 'greetings', letters: ['T', 'H', 'A', 'N', 'K', 'Y', 'O', 'U'],
              description: 'Express gratitude',
              gifId: 'l0MYrlUnFtq25TQR2',
              steps: ['Touch your chin with fingertips', 'Move hand forward and down', 'Like blowing a kiss of thanks'] },
            { id: 'please', text: 'Please', category: 'greetings', letters: ['P', 'L', 'E', 'A', 'S', 'E'],
              description: 'Polite request',
              gifId: 'l0MYEXSLkUipy1zVK',
              steps: ['Place flat hand on chest', 'Rub in circular motion', 'Shows sincerity'] },
            { id: 'sorry', text: 'Sorry', category: 'greetings', letters: ['S', 'O', 'R', 'R', 'Y'],
              description: 'Express apology',
              gifId: '3o7TKq0oNLk8ljH7vG',
              steps: ['Make A handshape (fist)', 'Rub in circle on chest', 'Shows remorse'] },
            { id: 'excuseme', text: 'Excuse Me', category: 'greetings', letters: ['E', 'X', 'C', 'U', 'S', 'E'],
              description: 'Get attention politely',
              gifId: '3o7TKU1FW62vZvPGbS',
              steps: ['Brush fingertips across opposite palm', 'Move hand outward', 'Gentle brushing motion'] },
            { id: 'yes', text: 'Yes', category: 'greetings', letters: ['Y', 'E', 'S'],
              description: 'Affirmative response',
              gifId: 'l4Jz0THKhQLo61NBK',
              steps: ['Make a fist (S hand)', 'Nod your fist up and down', 'Like your hand is nodding yes'] },
            { id: 'no', text: 'No', category: 'greetings', letters: ['N', 'O'],
              description: 'Negative response',
              gifId: 'l4Jz4faxuS1FiSEV2',
              steps: ['Extend index and middle fingers', 'Snap them down to meet thumb', 'Quick snapping motion'] },

            // ===== QUESTIONS =====
            { id: 'howareyou', text: 'How are you?', category: 'questions', letters: ['H', 'O', 'W', 'A', 'R', 'E', 'Y', 'O', 'U'],
              description: 'Ask about wellbeing',
              gifId: '26FLgm33ve3iUexZC',
              steps: ['Point to the person (YOU)', 'Make curved hands, palms up', 'Move up and down alternating', 'Raise eyebrows (question face)'] },
            { id: 'wherebathroom', text: 'Where is the bathroom?', category: 'questions', letters: ['B', 'A', 'T', 'H', 'R', 'O', 'O', 'M'],
              description: 'Ask for restroom location',
              gifId: 'l0MYKTHdq5SE9KV44',
              steps: ['Sign WHERE (shake index finger side to side)', 'Then sign BATHROOM (shake T handshape)', 'Use questioning expression'] },

            // ===== FEELINGS & STATES =====
            { id: 'happy', text: 'Happy', category: 'feelings', letters: ['H', 'A', 'P', 'P', 'Y'],
              description: 'Express happiness',
              gifId: '3o7TKFpahYpUp4g0N2',
              steps: ['Flat hand on chest', 'Brush upward twice', 'Show happy expression'] },
            { id: 'sad', text: 'Sad', category: 'feelings', letters: ['S', 'A', 'D'],
              description: 'Express sadness',
              gifId: '3o7TKVhsMTczdAzMB2',
              steps: ['Both hands open in front of face', 'Move downward', 'Show sad expression'] },
            { id: 'hungry', text: 'Hungry', category: 'feelings', letters: ['H', 'U', 'N', 'G', 'R', 'Y'],
              description: 'Express hunger',
              gifId: 'l3vR0xkdFEz4tnfTq',
              steps: ['C hand at throat', 'Move down toward stomach', 'Like food going down'] },
            { id: 'understand', text: 'I understand', category: 'feelings', letters: ['U', 'N', 'D', 'E', 'R', 'S', 'T', 'A', 'N', 'D'],
              description: 'Show comprehension',
              gifId: 'l4Jz6lkydXsNEfuWk',
              steps: ['Make a fist near forehead', 'Flick index finger up', 'Like a lightbulb turning on'] },
            { id: 'dontunderstand', text: "I don't understand", category: 'feelings', letters: ['D', 'O', 'N', 'T'],
              description: 'Express confusion',
              gifId: '26FL0X4d3Epuecpj2',
              steps: ['Touch forehead with index finger', 'Then move away while closing into fist', 'Shake head slightly'] },

            // ===== EVERYDAY NEEDS =====
            { id: 'help', text: 'Help', category: 'needs', letters: ['H', 'E', 'L', 'P'],
              description: 'Ask for assistance',
              gifId: '26FKWxLSlHTGeIdlS',
              steps: ['Make thumbs up with one hand', 'Place it on flat palm of other hand', 'Lift both hands up together'] },
            { id: 'water', text: 'Water', category: 'needs', letters: ['W', 'A', 'T', 'E', 'R'],
              description: 'Ask for water',
              gifId: '26DOtNnaZuvgS5wTS',
              steps: ['Make W hand (3 fingers up)', 'Tap index finger to chin twice', 'W for water at mouth'] },
            { id: 'food', text: 'Food', category: 'needs', letters: ['F', 'O', 'O', 'D'],
              description: 'Ask for food',
              gifId: '3oz8xKbhnsXuEnlKak',
              steps: ['Flat O hand (fingertips together)', 'Tap to mouth twice', 'Like putting food in mouth'] },
            { id: 'eat', text: 'Eat', category: 'needs', letters: ['E', 'A', 'T'],
              description: 'The action of eating',
              gifId: 'l3vRhFBHY2JT5QIdq',
              steps: ['Flat O hand at mouth', 'Move toward mouth repeatedly', 'Like eating motion'] },
            { id: 'wait', text: 'Wait', category: 'needs', letters: ['W', 'A', 'I', 'T'],
              description: 'Ask someone to wait',
              gifId: 'l0MYSzYfva1UzKyD6',
              steps: ['Both hands up, palms facing you', 'Wiggle fingers', 'Patient waiting gesture'] },

            // ===== WEATHER & SMALL TALK =====
            { id: 'weather', text: 'What is the weather?', category: 'smalltalk', letters: ['W', 'E', 'A', 'T', 'H', 'E', 'R'],
              description: 'Ask about weather',
              gifId: '3o6Ztgc9cktcGfLTH2',
              steps: ['Both W hands', 'Twist back and forth', 'Moving downward', 'Like weather changing'] },

            // ===== EMERGENCY =====
            { id: 'needhelp', text: 'I need help', category: 'emergency', letters: ['H', 'E', 'L', 'P'],
              description: 'Urgent request for help',
              gifId: '3oz8xxZjw8HJxLcmD6',
              steps: ['Point to yourself', 'Sign NEED (X hand bends down)', 'Sign HELP (thumbs up on palm, lift)', 'Urgent expression'] }
        ];
        
        // State
        let currentMode = 'learn';
        let lessonIndex = 0;
        let testSign = null;
        let practiceSign = null;
        let testScore = 0;
        let testTotal = 0;
        let practiceScore = 0;
        let practiceAttempts = 0;
        let hands = null;
        let testCamera = null;
        let practiceCamera = null;
        let lastDetectionTime = 0;
        let testCameraActive = false;
        let practiceCameraActive = false;

        // Body/Face skeleton detection (experimental)
        let holistic = null;
        let currentFaceLandmarks = null;
        let currentPoseLandmarks = null;
        let useHolisticMode = false; // Default OFF for better performance

        // Performance optimization settings
        let frameSkipCount = 0;
        const FRAME_SKIP = 2; // Process every 2nd frame (set to 1 for no skipping)
        const VIDEO_WIDTH = 480; // Reduced from 640
        const VIDEO_HEIGHT = 360; // Reduced from 480

        // DOM Elements
        const modeTabs = document.querySelectorAll('.mode-tab');
        const panels = document.querySelectorAll('.panel');
        
        // Initialize
        function init() {
            setupModeNavigation();
            renderLesson();
            generateTestQuestion();
            buildSignGrids();
            buildPhraseGrids();
        }
        
        // Mode Navigation
        function setupModeNavigation() {
            modeTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const mode = tab.dataset.mode;
                    modeTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    panels.forEach(p => p.classList.remove('active'));
                    document.getElementById(mode + 'Panel').classList.add('active');
                    currentMode = mode;
                });
            });
        }
        
        // Learn Mode
        function renderLesson() {
            const sign = SIGNS[lessonIndex];
            
            // Category labels and badges
            const categoryLabels = {
                'letter': 'Alphabet',
                'number': 'Numbers',
                'family': 'Family',
                'color': 'Colors',
                'day': 'Days',
                'season': 'Seasons',
                'holiday': 'Holidays'
            };
            const categoryBadges = {
                'letter': 'badge-coral',
                'number': 'badge-gold',
                'family': 'badge-sage',
                'color': 'badge-coral',
                'day': 'badge-gold',
                'season': 'badge-sage',
                'holiday': 'badge-coral'
            };
            const typeIcons = {
                'family': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                'color': 'üé®',
                'day': 'üìÖ',
                'season': 'üå§Ô∏è',
                'holiday': 'üéâ'
            };
            const isVocab = ['family', 'color', 'day', 'season', 'holiday'].includes(sign.type);

            document.getElementById('lessonTitle').textContent =
                sign.type === 'letter' ? `Letter ${sign.name}` :
                sign.type === 'number' ? `Number ${sign.name}` : sign.name;
            document.getElementById('lessonBadge').textContent = categoryLabels[sign.type] || sign.type;
            document.getElementById('lessonBadge').className = `badge ${categoryBadges[sign.type] || 'badge-coral'}`;

            // Handle image display for vocab items without hand images
            const lessonImg = document.getElementById('lessonImage');
            if (isVocab) {
                // Create or update vocab icon for lesson display
                let vocabLessonIcon = document.getElementById('lessonVocabIcon');
                if (!vocabLessonIcon) {
                    vocabLessonIcon = document.createElement('div');
                    vocabLessonIcon.id = 'lessonVocabIcon';
                    vocabLessonIcon.style.cssText = 'font-size: 120px; text-align: center; margin: 20px auto;';
                    lessonImg.parentNode.insertBefore(vocabLessonIcon, lessonImg);
                }
                vocabLessonIcon.textContent = typeIcons[sign.type] || 'üìù';
                vocabLessonIcon.style.display = 'block';
                lessonImg.style.display = 'none';
            } else {
                lessonImg.style.display = 'block';
                lessonImg.src = ASL_IMAGES[sign.id];
                const vocabLessonIcon = document.getElementById('lessonVocabIcon');
                if (vocabLessonIcon) vocabLessonIcon.style.display = 'none';
            }
            document.getElementById('lessonLetter').textContent = sign.name;
            document.getElementById('lessonDesc').textContent = sign.desc;
            
            const stepsList = document.getElementById('lessonSteps');
            stepsList.innerHTML = sign.steps.map((step, i) => `
                <li class="step-item">
                    <span class="step-num">${i + 1}</span>
                    <span class="step-text">${step}</span>
                </li>
            `).join('');
            
            document.getElementById('progressText').textContent = `${lessonIndex + 1} of ${SIGNS.length}`;
            document.getElementById('progressBar').style.width = `${((lessonIndex + 1) / SIGNS.length) * 100}%`;
            
            document.getElementById('prevBtn').disabled = lessonIndex === 0;
            document.getElementById('nextBtn').textContent = 
                lessonIndex === SIGNS.length - 1 ? 'Complete! üéâ' : 'Next ‚Üí';
        }
        
        document.getElementById('prevBtn').addEventListener('click', () => {
            if (lessonIndex > 0) {
                lessonIndex--;
                renderLesson();
            }
        });
        
        document.getElementById('nextBtn').addEventListener('click', () => {
            if (lessonIndex < SIGNS.length - 1) {
                lessonIndex++;
                renderLesson();
            }
        });
        
        // Test Mode
        function generateTestQuestion() {
            testSign = SIGNS[Math.floor(Math.random() * SIGNS.length)];
            document.getElementById('testPromptImage').src = ASL_IMAGES[testSign.id];
            document.getElementById('testPromptLetter').textContent = testSign.name;
            document.getElementById('testFeedback').textContent = 'Make the sign shown above';
            document.getElementById('testFeedback').className = 'feedback-banner waiting';
        }
        
        document.getElementById('skipBtn').addEventListener('click', generateTestQuestion);
        
        // Practice Mode - Build Grids
        function buildSignGrids() {
            const alphabetGrid = document.getElementById('alphabetGrid');
            const numbersGrid = document.getElementById('numbersGrid');
            const familyGrid = document.getElementById('familyGrid');
            const colorsGrid = document.getElementById('colorsGrid');
            const daysGrid = document.getElementById('daysGrid');
            const seasonsGrid = document.getElementById('seasonsGrid');
            const holidaysGrid = document.getElementById('holidaysGrid');

            SIGNS.filter(s => s.type === 'letter').forEach(sign => {
                const tile = createSignTile(sign);
                alphabetGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'number').forEach(sign => {
                const tile = createSignTile(sign);
                numbersGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'family').forEach(sign => {
                const tile = createSignTile(sign, true);
                familyGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'color').forEach(sign => {
                const tile = createSignTile(sign, true);
                colorsGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'day').forEach(sign => {
                const tile = createSignTile(sign, true);
                daysGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'season').forEach(sign => {
                const tile = createSignTile(sign, true);
                seasonsGrid.appendChild(tile);
            });

            SIGNS.filter(s => s.type === 'holiday').forEach(sign => {
                const tile = createSignTile(sign, true);
                holidaysGrid.appendChild(tile);
            });
        }
        
        function createSignTile(sign, isVocab = false) {
            const tile = document.createElement('button');
            tile.className = 'sign-tile' + (isVocab ? ' vocab-tile' : '');
            tile.dataset.id = sign.id;
            if (isVocab) {
                // Vocabulary items show an icon/emoji instead of hand image
                const typeIcons = {
                    'family': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                    'color': 'üé®',
                    'day': 'üìÖ',
                    'season': 'üå§Ô∏è',
                    'holiday': 'üéâ'
                };
                tile.innerHTML = `
                    <span class="vocab-icon">${typeIcons[sign.type] || 'üìù'}</span>
                    <span class="sign-tile-label">${sign.name}</span>
                `;
            } else {
                tile.innerHTML = `
                    <img src="${ASL_IMAGES[sign.id]}" alt="${sign.name}">
                    <span class="sign-tile-label">${sign.name}</span>
                `;
            }
            tile.addEventListener('click', () => selectPracticeSign(sign, tile));
            return tile;
        }
        
        function selectPracticeSign(sign, tile) {
            practiceSign = sign;
            document.querySelectorAll('.sign-tile').forEach(t => t.classList.remove('active'));
            tile.classList.add('active');
            document.getElementById('practiceFeedback').textContent = `Practice: ${sign.name}`;
            document.getElementById('practiceFeedback').className = 'feedback-banner prompt';

            // Check if this is a vocabulary item (no hand image)
            const isVocab = ['family', 'color', 'day', 'season', 'holiday'].includes(sign.type);
            const typeIcons = {
                'family': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                'color': 'üé®',
                'day': 'üìÖ',
                'season': 'üå§Ô∏è',
                'holiday': 'üéâ'
            };

            // Show and update the selected sign preview
            const preview = document.getElementById('selectedSignPreview');
            preview.style.display = 'block';

            const imageEl = document.getElementById('selectedSignImage');
            if (isVocab) {
                // For vocab items, hide the image and show text-based content
                imageEl.style.display = 'none';
                // Add or update a vocab icon display
                let vocabIconEl = document.getElementById('selectedVocabIcon');
                if (!vocabIconEl) {
                    vocabIconEl = document.createElement('div');
                    vocabIconEl.id = 'selectedVocabIcon';
                    vocabIconEl.style.cssText = 'font-size: 80px; text-align: center; width: 150px;';
                    imageEl.parentNode.insertBefore(vocabIconEl, imageEl);
                }
                vocabIconEl.textContent = typeIcons[sign.type] || 'üìù';
                vocabIconEl.style.display = 'block';
            } else {
                imageEl.style.display = 'block';
                imageEl.src = ASL_IMAGES[sign.id];
                const vocabIconEl = document.getElementById('selectedVocabIcon');
                if (vocabIconEl) vocabIconEl.style.display = 'none';
            }

            document.getElementById('selectedSignLetter').textContent = sign.name;
            document.getElementById('selectedSignDesc').textContent = sign.desc;

            // Scroll the preview into view
            preview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Build Phrase Grids
        function buildPhraseGrids() {
            const grids = {
                greetings: document.getElementById('greetingsGrid'),
                questions: document.getElementById('questionsGrid'),
                feelings: document.getElementById('feelingsGrid'),
                needs: document.getElementById('needsGrid'),
                aboutme: document.getElementById('aboutmeGrid'),
                smalltalk: document.getElementById('smalltalkGrid'),
                pets: document.getElementById('petsGrid'),
                emergency: document.getElementById('emergencyGrid')
            };
            
            // Check if grids exist
            if (!grids.greetings) return;
            
            PHRASES.forEach(phrase => {
                const tile = document.createElement('div');
                tile.className = 'phrase-tile';
                
                // Add video indicator if GIF available
                const videoIcon = phrase.gifId ? '<span style="color: var(--sage);">‚ñ∂</span>' : '';
                
                tile.innerHTML = `
                    <div>
                        <div class="phrase-tile-text">${phrase.text} ${videoIcon}</div>
                        <div class="phrase-tile-asl">${phrase.letters.join('-')}</div>
                    </div>
                    <span style="font-size: 20px;">üëâ</span>
                `;
                tile.addEventListener('click', () => selectPhrase(phrase, tile));
                
                // Add to appropriate grid
                const grid = grids[phrase.category];
                if (grid) {
                    grid.appendChild(tile);
                }
            });
        }
        
        // Select and display a phrase
        function selectPhrase(phrase, tile) {
            // Update active state
            document.querySelectorAll('.phrase-tile').forEach(t => t.classList.remove('active'));
            tile.classList.add('active');
            
            // Show phrase display card
            const card = document.getElementById('phraseDisplayCard');
            card.style.display = 'block';
            
            // Update title and badge
            document.getElementById('phraseTitle').textContent = phrase.text;
            document.getElementById('phraseBadge').textContent = 
                phrase.category.charAt(0).toUpperCase() + phrase.category.slice(1);
            document.getElementById('phraseDescription').textContent = phrase.description;
            
            // Build letter cards
            const container = document.getElementById('phraseLettersContainer');
            container.innerHTML = '';
            
            phrase.letters.forEach(letter => {
                const letterCard = document.createElement('div');
                letterCard.className = 'phrase-letter-card';
                const signId = letter.toLowerCase();
                letterCard.innerHTML = `
                    <img src="${ASL_IMAGES[signId]}" alt="${letter}">
                    <div class="letter-label">${letter}</div>
                `;
                container.appendChild(letterCard);
            });
            
            // Build steps
            const stepsList = document.getElementById('phraseStepsList');
            stepsList.innerHTML = phrase.steps.map(step => `<li>${step}</li>`).join('');
            
            // Show GIF if available
            const gifIframe = document.getElementById('phraseGif');
            const gifWrapper = document.getElementById('phraseGifWrapper');
            const noGifMessage = document.getElementById('noGifMessage');
            
            if (phrase.gifId) {
                gifIframe.src = `https://giphy.com/embed/${phrase.gifId}`;
                gifWrapper.style.display = 'block';
                noGifMessage.style.display = 'none';
            } else {
                gifIframe.src = '';
                gifWrapper.style.display = 'none';
                noGifMessage.style.display = 'block';
            }
            
            // Scroll to card
            card.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Phrases Camera functionality
        let phrasesCameraActive = false;
        let phrasesHands = null;
        let phrasesHolistic = null;

        function onPhrasesResults(results) {
            const canvas = document.getElementById('phrasesCanvas');
            const video = document.getElementById('phrasesVideo');
            const ctx = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw body skeleton if holistic data is available
            if (results.poseLandmarks || results.faceLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                currentFaceLandmarks = results.faceLandmarks;
                drawBodySkeleton(ctx, results.poseLandmarks, results.faceLandmarks, canvas.width, canvas.height);
            }

            // Get hand landmarks - works with both Hands and Holistic
            const handLandmarks = results.multiHandLandmarks?.[0] ||
                                  results.leftHandLandmarks ||
                                  results.rightHandLandmarks;

            // Draw hand skeleton if detected
            if (handLandmarks) {
                drawHand(ctx, handLandmarks, canvas.width, canvas.height);

                // Also draw trails for practice
                const indexExt = handLandmarks[8].y < handLandmarks[6].y - 0.02;
                const middleExt = handLandmarks[12].y < handLandmarks[10].y - 0.02;
                const ringExt = handLandmarks[16].y < handLandmarks[14].y - 0.02;
                const pinkyExt = handLandmarks[20].y < handLandmarks[18].y - 0.02;

                const isJPose = !indexExt && !middleExt && !ringExt && pinkyExt;
                const isZPose = indexExt && !middleExt && !ringExt && !pinkyExt;

                updateTrails(handLandmarks, isJPose, isZPose);
                drawTrails(ctx, canvas.width, canvas.height);
            }
        }
        
        async function startPhrasesCamera() {
            const video = document.getElementById('phrasesVideo');
            const btn = document.getElementById('phrasesCameraBtn');
            const placeholder = document.getElementById('phrasesPlaceholder');

            btn.textContent = 'Loading...';
            btn.disabled = true;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: VIDEO_WIDTH }, height: { ideal: VIDEO_HEIGHT } }
                });
                video.srcObject = stream;

                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                // Use Holistic for body skeleton detection
                if (useHolisticMode) {
                    console.log('Phrases camera: Initializing MediaPipe Holistic (lite mode)...');
                    const holisticInstance = new Holistic({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
                    });

                    holisticInstance.setOptions({
                        modelComplexity: 0, // Lite mode for better performance
                        smoothLandmarks: true,
                        enableSegmentation: false,
                        smoothSegmentation: false,
                        refineFaceLandmarks: false, // Disabled for performance
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    holisticInstance.onResults(onPhrasesResults);
                    await holisticInstance.initialize();

                    phrasesHolistic = holisticInstance;
                    phrasesCameraActive = true;

                    const processFrame = async () => {
                        if (phrasesCameraActive && video.readyState >= 2) {
                            // Frame skipping for performance
                            frameSkipCount++;
                            if (frameSkipCount >= FRAME_SKIP) {
                                frameSkipCount = 0;
                                await phrasesHolistic.send({ image: video });
                            }
                        }
                        if (phrasesCameraActive) {
                            requestAnimationFrame(processFrame);
                        }
                    };

                    placeholder.style.display = 'none';
                    btn.textContent = 'Stop Camera';
                    btn.disabled = false;

                    requestAnimationFrame(processFrame);
                    console.log('Phrases camera started with body skeleton detection');
                } else {
                    // Fallback to hands-only mode
                    const handsInstance = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                    });

                    handsInstance.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    handsInstance.onResults(onPhrasesResults);
                    await handsInstance.initialize();

                    phrasesHands = handsInstance;
                    phrasesCameraActive = true;

                    const processFrame = async () => {
                        if (phrasesCameraActive && video.readyState >= 2) {
                            await phrasesHands.send({ image: video });
                        }
                        if (phrasesCameraActive) {
                            requestAnimationFrame(processFrame);
                        }
                    };

                    placeholder.style.display = 'none';
                    btn.textContent = 'Stop Camera';
                    btn.disabled = false;

                    requestAnimationFrame(processFrame);
                }

            } catch (error) {
                console.error('Phrases camera error:', error);
                btn.textContent = 'Camera Error - Try Again';
                btn.disabled = false;
            }
        }
        
        function stopPhrasesCamera() {
            const video = document.getElementById('phrasesVideo');
            const btn = document.getElementById('phrasesCameraBtn');
            const placeholder = document.getElementById('phrasesPlaceholder');
            const canvas = document.getElementById('phrasesCanvas');
            
            phrasesCameraActive = false;
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            placeholder.style.display = 'flex';
            btn.textContent = 'Start Practice Camera';
        }
        
        // Phrases camera button listener
        document.getElementById('phrasesCameraBtn').addEventListener('click', async () => {
            if (phrasesCameraActive) {
                stopPhrasesCamera();
            } else {
                await startPhrasesCamera();
            }
        });
        
        // Hand Detection Logic

        // ============ FINGER TRAIL TRACKING SYSTEM ============
        
        // Trail storage - stores recent positions for tracked fingers
        const fingerTrails = {
            index: [],   // Landmark 8 - for Z detection
            pinky: []    // Landmark 20 - for J detection
        };
        
        const TRAIL_MAX_LENGTH = 60;  // Number of points to keep
        const TRAIL_FADE_TIME = 2000;  // ms before trail fades (2 seconds for J motion)
        
        // Add a point to a finger's trail
        function addTrailPoint(finger, x, y, timestamp) {
            fingerTrails[finger].push({ x, y, timestamp });
            
            // Remove old points
            const now = Date.now();
            fingerTrails[finger] = fingerTrails[finger].filter(
                p => now - p.timestamp < TRAIL_FADE_TIME
            );
            
            // Limit length
            if (fingerTrails[finger].length > TRAIL_MAX_LENGTH) {
                fingerTrails[finger].shift();
            }
        }
        
        // Clear trails
        function clearTrails() {
            fingerTrails.index = [];
            fingerTrails.pinky = [];
        }
        
        // Draw trails on canvas
        function drawTrails(ctx, width, height) {
            const now = Date.now();
            
            // Draw pinky trail (magenta/pink for J)
            if (fingerTrails.pinky.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#FF00FF';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < fingerTrails.pinky.length; i++) {
                    const point = fingerTrails.pinky[i];
                    const age = now - point.timestamp;
                    const alpha = Math.max(0, 1 - (age / TRAIL_FADE_TIME));
                    
                    const x = point.x * width;
                    const y = point.y * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.globalAlpha = 0.8;
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Draw dot at current position
                if (fingerTrails.pinky.length > 0) {
                    const last = fingerTrails.pinky[fingerTrails.pinky.length - 1];
                    ctx.beginPath();
                    ctx.arc(last.x * width, last.y * height, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = '#FF00FF';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(last.x * width, last.y * height, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fill();
                }
            }
            
            // Draw index trail (cyan for Z)
            if (fingerTrails.index.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < fingerTrails.index.length; i++) {
                    const point = fingerTrails.index[i];
                    const x = point.x * width;
                    const y = point.y * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.globalAlpha = 0.8;
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Draw dot at current position
                if (fingerTrails.index.length > 0) {
                    const last = fingerTrails.index[fingerTrails.index.length - 1];
                    ctx.beginPath();
                    ctx.arc(last.x * width, last.y * height, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = '#00FFFF';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(last.x * width, last.y * height, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fill();
                }
            }
        }
        
        // Analyze trail for J pattern (pinky draws hook: down then curve)
        function detectJMotion() {
            const trail = fingerTrails.pinky;
            if (trail.length < 8) return false;  // Reduced from 10
            
            // Get start, middle, and end points
            const start = trail[0];
            const end = trail[trail.length - 1];
            const mid = trail[Math.floor(trail.length / 2)];
            
            // Calculate total vertical movement
            const totalVertical = end.y - start.y;
            
            // Calculate total horizontal movement (for the hook)
            const totalHorizontal = Math.abs(end.x - start.x);
            
            // J motion: significant downward movement with some horizontal curve
            // More lenient: just needs to go down and have some horizontal component
            const wentDown = totalVertical > 0.06;  // Moved down
            const hasCurve = totalHorizontal > 0.03 || Math.abs(end.x - mid.x) > 0.02;
            
            // Alternative: check if there's a direction change (went down then sideways)
            const midVertical = mid.y - start.y;
            const endFromMid = end.y - mid.y;
            const horizontalAtEnd = Math.abs(end.x - mid.x);
            
            // Either: went down overall with curve, OR went down then leveled off with horizontal
            const pattern1 = wentDown && hasCurve;
            const pattern2 = midVertical > 0.04 && horizontalAtEnd > 0.02;
            
            return pattern1 || pattern2;
        }
        
        // Analyze trail for Z pattern (index draws: right, diagonal down-left, right)
        function detectZMotion() {
            const trail = fingerTrails.index;
            if (trail.length < 8) return false;  // Reduced minimum
            
            // Get key points from the trail
            const start = trail[0];
            const end = trail[trail.length - 1];
            const mid = trail[Math.floor(trail.length / 2)];
            
            // Z motion: should have overall horizontal movement with a diagonal section
            // More lenient detection:
            
            // Total horizontal movement
            const totalHorizontal = Math.abs(end.x - start.x);
            
            // There should be some vertical movement in the middle (the diagonal)
            const hasVertical = Math.abs(end.y - start.y) > 0.02 || 
                               Math.abs(mid.y - start.y) > 0.03;
            
            // The path should have some complexity (not just a straight line)
            // Check if mid point deviates from straight line
            const expectedMidY = (start.y + end.y) / 2;
            const midDeviation = Math.abs(mid.y - expectedMidY);
            
            // Either: significant horizontal + vertical, OR clear deviation pattern
            const pattern1 = totalHorizontal > 0.04 && hasVertical;
            const pattern2 = midDeviation > 0.02 && totalHorizontal > 0.03;
            
            // Also accept if there's clear directional changes
            const quarterLen = Math.floor(trail.length / 4);
            if (trail.length >= 8) {
                const q1 = trail[quarterLen];
                const q3 = trail[quarterLen * 3];
                const hasZigZag = (q1.y !== mid.y || q3.y !== mid.y) && totalHorizontal > 0.03;
                return pattern1 || pattern2 || hasZigZag;
            }
            
            return pattern1 || pattern2;
        }
        
        // Update trails based on current hand landmarks and hand state
        function updateTrails(landmarks, isJPose, isZPose) {
            const now = Date.now();
            
            // Only track pinky when in I/J pose (pinky extended, others closed)
            if (isJPose) {
                addTrailPoint('pinky', landmarks[20].x, landmarks[20].y, now);
            } else {
                // Clear pinky trail if not in J pose
                if (fingerTrails.pinky.length > 0) {
                    fingerTrails.pinky = [];
                }
            }
            
            // Only track index when in Z pose (index extended, others closed)
            if (isZPose) {
                addTrailPoint('index', landmarks[8].x, landmarks[8].y, now);
            } else {
                // Clear index trail if not in Z pose
                if (fingerTrails.index.length > 0) {
                    fingerTrails.index = [];
                }
            }
        }

        // ============ IMPROVED HAND DETECTION ============
        
        // Helper: Calculate distance between two landmarks
        function landmarkDist(landmarks, i, j) {
            const dx = landmarks[i].x - landmarks[j].x;
            const dy = landmarks[i].y - landmarks[j].y;
            const dz = (landmarks[i].z || 0) - (landmarks[j].z || 0);
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Helper: Check if finger is extended (improved)
        function isFingerExtended(landmarks, tipIdx, pipIdx, mcpIdx) {
            // Finger is extended if tip is further from palm than pip
            const tipToPalm = landmarkDist(landmarks, tipIdx, 0);
            const pipToPalm = landmarkDist(landmarks, pipIdx, 0);
            const tipY = landmarks[tipIdx].y;
            const pipY = landmarks[pipIdx].y;
            const mcpY = landmarks[mcpIdx].y;
            
            // Extended if tip is above pip (more lenient threshold)
            return tipY < pipY - 0.01 && tipToPalm > pipToPalm * 0.85;
        }
        
        // Helper: Check if finger is curled/bent
        function isFingerCurled(landmarks, tipIdx, pipIdx, mcpIdx) {
            const tipY = landmarks[tipIdx].y;
            const pipY = landmarks[pipIdx].y;
            const mcpY = landmarks[mcpIdx].y;
            
            // Curled if tip is below or at same level as mcp
            return tipY > mcpY - 0.02;
        }
        
        // Helper: Check thumb position
        function getThumbState(landmarks) {
            const thumbTip = landmarks[4];
            const thumbIp = landmarks[3];
            const thumbMcp = landmarks[2];
            const indexMcp = landmarks[5];
            const wrist = landmarks[0];
            
            // Is thumb extended outward?
            const thumbOutward = Math.abs(thumbTip.x - wrist.x) > Math.abs(indexMcp.x - wrist.x) * 0.7;
            
            // Is thumb across palm (toward pinky side)?
            const thumbAcross = (thumbTip.x > indexMcp.x + 0.03) || (thumbTip.x < indexMcp.x - 0.03);
            
            // Is thumb up (above index mcp)?
            const thumbUp = thumbTip.y < indexMcp.y - 0.05;
            
            // Is thumb tucked (close to palm)?
            const thumbTucked = landmarkDist(landmarks, 4, 9) < 0.1;
            
            // Is thumb between index and middle?
            const thumbBetweenIM = thumbTip.y < landmarks[8].y && 
                                   thumbTip.y > landmarks[5].y &&
                                   Math.abs(thumbTip.x - landmarks[5].x) < 0.08;
            
            return { thumbOutward, thumbAcross, thumbUp, thumbTucked, thumbBetweenIM };
        }
        
        // Helper: Get angle of hand (for G, H, P, Q detection)
        function getHandAngle(landmarks) {
            const wrist = landmarks[0];
            const middleMcp = landmarks[9];
            
            const dx = middleMcp.x - wrist.x;
            const dy = middleMcp.y - wrist.y;
            
            // Angle in degrees, 0 = pointing up, 90 = pointing right
            let angle = Math.atan2(dx, -dy) * 180 / Math.PI;
            return angle;
        }
        
        // Helper: Check if two fingers are touching
        function fingersTouching(landmarks, tip1, tip2, threshold = 0.05) {
            return landmarkDist(landmarks, tip1, tip2) < threshold;
        }
        
        // Helper: Check if fingers are spread apart
        function fingersSpread(landmarks, tip1, tip2, threshold = 0.06) {
            return landmarkDist(landmarks, tip1, tip2) > threshold;
        }
        
        // Main detection function with improved accuracy
        function detectSign(landmarks, targetSign) {
            if (!landmarks || !targetSign) return false;
            
            // Get detailed finger states
            const indexExt = isFingerExtended(landmarks, 8, 6, 5);
            const middleExt = isFingerExtended(landmarks, 12, 10, 9);
            const ringExt = isFingerExtended(landmarks, 16, 14, 13);
            const pinkyExt = isFingerExtended(landmarks, 20, 18, 17);
            
            const indexCurled = isFingerCurled(landmarks, 8, 6, 5);
            const middleCurled = isFingerCurled(landmarks, 12, 10, 9);
            const ringCurled = isFingerCurled(landmarks, 16, 14, 13);
            const pinkyCurled = isFingerCurled(landmarks, 20, 18, 17);
            
            const thumb = getThumbState(landmarks);
            const handAngle = getHandAngle(landmarks);
            
            // Detect specific signs with improved logic
            const id = targetSign.id;
            
            // ===== LETTERS =====
            
            // A: Fist with thumb prominently to the SIDE (not up, not tucked)
            if (id === 'a') {
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                const thumbTip = landmarks[4];
                const thumbIp = landmarks[3];
                const indexMcp = landmarks[5];
                const indexPip = landmarks[6];
                const middlePip = landmarks[10];
                
                // KEY: Thumb is to the SIDE - horizontally offset from fingers
                const thumbToSide = Math.abs(thumbTip.x - indexMcp.x) > 0.05;
                
                // Thumb should NOT be poking up above the index PIP (that's T)
                const thumbNotAboveFist = thumbTip.y > indexPip.y - 0.04;
                
                // Thumb should NOT be between index and middle (that's T)
                const thumbNotBetween = Math.abs(thumbTip.x - (indexPip.x + middlePip.x) / 2) > 0.04 ||
                                        thumbTip.y > indexPip.y;
                
                // Thumb should be visible/extended, not completely tucked
                const thumbVisible = landmarkDist(landmarks, 4, 2) > 0.05;
                
                return allFingersClosed && thumbToSide && thumbNotAboveFist && thumbVisible;
            }
            
            // B: Four fingers up straight, thumb folded across palm (not sticking out)
            if (id === 'b') {
                // All four fingers must be extended upward
                const allFingersUp = indexExt && middleExt && ringExt && pinkyExt;
                
                // Thumb must NOT be sticking out to the side like in "5"
                // Thumb tip should be close to the palm/fingers, not extended outward
                const thumbTip = landmarks[4];
                const indexMcp = landmarks[5];
                const wrist = landmarks[0];
                
                // Thumb not sticking out far from the hand
                const thumbNotWideOut = Math.abs(thumbTip.x - indexMcp.x) < 0.12;
                
                // Thumb should be below or level with index MCP (not sticking up)
                const thumbNotUp = thumbTip.y > indexMcp.y - 0.05;
                
                return allFingersUp && (thumbNotWideOut || thumbNotUp);
            }
            
            // C: Curved hand (all fingers curved, thumb out) - hard to detect precisely
            if (id === 'c') {
                return !indexExt && !middleExt && !ringExt && !pinkyExt &&
                       !indexCurled && !middleCurled && // Partially bent, not fully curled
                       thumb.thumbOutward;
            }
            
            // D: Index up, others touch thumb
            if (id === 'd') {
                return indexExt && !middleExt && !ringExt && !pinkyExt &&
                       fingersTouching(landmarks, 12, 4, 0.08); // Middle touches thumb
            }
            
            // E: All fingers curled, thumb tucked UNDER/across the fingers
            if (id === 'e') {
                // E: Claw-like shape with all fingers curled, thumb tucked under them
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                // Thumb should be tucked - close to or under the fingers
                const thumbTip = landmarks[4];
                const indexMcp = landmarks[5];
                const indexPip = landmarks[6];
                
                // Thumb tip is under/behind the curled fingers
                // Thumb y should be near or below the finger PIPs
                const thumbTucked = thumbTip.y > indexPip.y - 0.02;
                
                // Thumb not sticking out to side
                const thumbNotOut = Math.abs(thumbTip.x - indexMcp.x) < 0.06;
                
                return allFingersClosed && thumbTucked && thumbNotOut;
            }
            
            // F: Index+thumb touch (OK shape), other fingers up
            if (id === 'f') {
                return fingersTouching(landmarks, 8, 4, 0.06) &&
                       middleExt && ringExt && pinkyExt;
            }
            
            // G: Index extended with thumb also extended/visible, others closed
            if (id === 'g') {
                // G: Index pointing out, thumb also extended, others closed
                const indexTip = landmarks[8];
                const indexMcp = landmarks[5];
                const thumbTip = landmarks[4];
                
                // Index extended outward
                const indexOut = landmarkDist(landmarks, 8, 5) > landmarkDist(landmarks, 6, 5);
                
                // Thumb also extended (not tucked)
                const thumbExtended = landmarkDist(landmarks, 4, 2) > 0.08;
                
                // Middle, ring, pinky closed
                const middleDown = landmarks[12].y > landmarks[10].y - 0.02 || 
                                   landmarkDist(landmarks, 12, 9) < landmarkDist(landmarks, 10, 9);
                const ringDown = landmarks[16].y > landmarks[14].y - 0.02;
                const pinkyDown = landmarks[20].y > landmarks[18].y - 0.02;
                
                // Index and thumb roughly parallel (for G shape)
                const indexThumbClose = landmarkDist(landmarks, 8, 4) < 0.2;
                
                return indexOut && thumbExtended && middleDown && ringDown && pinkyDown;
            }
            
            // H: Index + middle extended together, pointing sideways
            if (id === 'h') {
                // For H, detect index and middle extended and close together
                // Don't rely on hand angle - just check finger extension pattern
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const indexMcp = landmarks[5];
                const middleMcp = landmarks[9];
                
                // Both fingers extended (tips away from MCPs)
                const indexOut = landmarkDist(landmarks, 8, 5) > landmarkDist(landmarks, 6, 5);
                const middleOut = landmarkDist(landmarks, 12, 9) > landmarkDist(landmarks, 10, 9);
                
                // Fingers close together
                const fingersTogether = landmarkDist(landmarks, 8, 12) < 0.08;
                
                // Ring and pinky not extended
                const ringDown = landmarks[16].y > landmarks[14].y - 0.02;
                const pinkyDown = landmarks[20].y > landmarks[18].y - 0.02;
                
                // Thumb not prominently out
                const thumbQuiet = landmarkDist(landmarks, 4, 5) < 0.15;
                
                return indexOut && middleOut && fingersTogether && ringDown && pinkyDown && thumbQuiet;
            }
            
            // I: Pinky up only
            if (id === 'i') {
                return !indexExt && !middleExt && !ringExt && pinkyExt &&
                       !thumb.thumbOutward;
            }
            
            // J: Pinky up + drawing J motion (tracked via trail)
            if (id === 'j') {
                const inJPose = !indexExt && !middleExt && !ringExt && pinkyExt;
                if (inJPose && detectJMotion()) {
                    clearTrails(); // Clear after successful detection
                    return true;
                }
                return false;
            }
            
            // K: Index + middle up in V, thumb wedged up between them
            if (id === 'k') {
                // Thumb tip should be between index and middle MCPs vertically
                // and close to the gap between index and middle fingers
                const thumbTip = landmarks[4];
                const indexMcp = landmarks[5];
                const middleMcp = landmarks[9];
                const indexPip = landmarks[6];
                const middlePip = landmarks[10];
                
                // Thumb should be elevated (above the MCPs)
                const thumbElevated = thumbTip.y < indexMcp.y;
                
                // Thumb x should be between index and middle
                const thumbXBetween = (thumbTip.x > Math.min(indexPip.x, middlePip.x) - 0.03) &&
                                      (thumbTip.x < Math.max(indexPip.x, middlePip.x) + 0.03);
                
                // Thumb should be close to the fingers (not sticking way out)
                const thumbClose = landmarkDist(landmarks, 4, 6) < 0.15;
                
                // Fingers should be spread (V shape)
                const fingersInV = fingersSpread(landmarks, 8, 12, 0.04);
                
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       thumbElevated && thumbXBetween && thumbClose && fingersInV &&
                       Math.abs(handAngle) < 50;
            }
            
            // L: Index up + thumb out (L shape)
            if (id === 'l') {
                return indexExt && !middleExt && !ringExt && !pinkyExt &&
                       thumb.thumbOutward &&
                       Math.abs(handAngle) < 45; // Hand pointing up
            }
            
            // M: Fist with index, middle, ring fingers draped OVER the thumb
            if (id === 'm') {
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const indexPip = landmarks[6];
                
                // KEY for M: THREE fingertips (index, middle, ring) are BELOW thumb tip
                // (fingers draped over thumb)
                const indexOverThumb = indexTip.y > thumbTip.y - 0.02;
                const middleOverThumb = middleTip.y > thumbTip.y - 0.02;
                const ringOverThumb = ringTip.y > thumbTip.y - 0.02;
                
                // Pinky should NOT be over thumb (that distinguishes from just a fist)
                // Actually in M, pinky is also tucked but separately
                
                // Thumb should be somewhat tucked (not sticking out to side)
                const thumbNotToSide = Math.abs(thumbTip.x - landmarks[5].x) < 0.07;
                
                // Thumb should not be poking up above fist
                const thumbNotUp = thumbTip.y > indexPip.y - 0.03;
                
                return allFingersClosed && indexOverThumb && middleOverThumb && ringOverThumb && 
                       thumbNotToSide && thumbNotUp;
            }
            
            // N: Fist with index and middle fingers draped OVER thumb (only 2 fingers, not 3)
            if (id === 'n') {
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const indexPip = landmarks[6];
                
                // KEY for N: TWO fingertips (index, middle) are BELOW/over thumb tip
                const indexOverThumb = indexTip.y > thumbTip.y - 0.02;
                const middleOverThumb = middleTip.y > thumbTip.y - 0.02;
                
                // Ring finger should NOT be over thumb (this distinguishes N from M)
                const ringNotOverThumb = ringTip.y < thumbTip.y + 0.02;
                
                // Thumb should not be to the side (that's A)
                const thumbNotToSide = Math.abs(thumbTip.x - landmarks[5].x) < 0.07;
                
                // Thumb not poking up (that's T)
                const thumbNotUp = thumbTip.y > indexPip.y - 0.02;
                
                return allFingersClosed && indexOverThumb && middleOverThumb && 
                       ringNotOverThumb && thumbNotToSide && thumbNotUp;
            }
            
            // O: Fingertips curl to touch thumb tip, forming a circle
            if (id === 'o') {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                
                // KEY for O: Fingertips are CLOSE to thumb tip (touching to form circle)
                const indexTouchesThumb = landmarkDist(landmarks, 8, 4) < 0.08;
                const middleTouchesThumb = landmarkDist(landmarks, 12, 4) < 0.10;
                
                // Fingers should be curved, not straight
                const fingersCurved = !indexExt && !middleExt;
                
                // This should NOT trigger for M/N where fingers are OVER thumb
                // In O, the fingertips are at roughly same Y level as thumb (forming circle)
                const fingersNotOverThumb = indexTip.y < thumbTip.y + 0.05;
                
                return indexTouchesThumb && fingersCurved && fingersNotOverThumb;
            }
            
            // P: Index + middle extended, pointing downward
            if (id === 'p') {
                // P: Two fingers out, hand oriented so fingers point down
                // Key: fingertips should be BELOW the wrist or MCPs
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const wrist = landmarks[0];
                const indexMcp = landmarks[5];
                
                // Fingers extended
                const indexOut = landmarkDist(landmarks, 8, 5) > landmarkDist(landmarks, 6, 5) * 0.8;
                const middleOut = landmarkDist(landmarks, 12, 9) > landmarkDist(landmarks, 10, 9) * 0.8;
                
                // Pointing down: fingertips below MCPs
                const tipsBelow = indexTip.y > indexMcp.y && middleTip.y > landmarks[9].y;
                
                // Or: fingertips lower than wrist (hand inverted)
                const belowWrist = indexTip.y > wrist.y - 0.05;
                
                // Ring and pinky closed
                const ringDown = !ringExt;
                const pinkyDown = !pinkyExt;
                
                return indexOut && middleOut && (tipsBelow || belowWrist) && ringDown && pinkyDown;
            }
            
            // Q: Index + thumb pointing downward
            if (id === 'q') {
                // Q: Like G but pointing down - index and thumb out, pointing down
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const wrist = landmarks[0];
                const indexMcp = landmarks[5];
                
                // Index extended
                const indexOut = landmarkDist(landmarks, 8, 5) > landmarkDist(landmarks, 6, 5) * 0.8;
                
                // Thumb extended
                const thumbOut = landmarkDist(landmarks, 4, 2) > 0.08;
                
                // Pointing down: index tip below MCP or wrist
                const pointingDown = indexTip.y > indexMcp.y || indexTip.y > wrist.y - 0.05;
                
                // Other fingers closed
                const othersDown = !middleExt && !ringExt && !pinkyExt;
                
                return indexOut && thumbOut && pointingDown && othersDown;
            }
            
            // R: Index and middle crossed
            if (id === 'r') {
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       landmarkDist(landmarks, 8, 12) < 0.04; // Fingertips very close (crossed)
            }
            
            // S: Fist with thumb wrapped over fingers (in front of fist)
            if (id === 's') {
                // S: All fingers closed into fist, thumb wraps over the front
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                // For S, the thumb is in front of the fingers (closer to camera)
                // This means thumb z should be less than finger z (if available)
                // Or thumb tip is positioned across the fingers
                
                // Thumb should be across the front of the fist
                // Thumb tip x should be roughly in line with or past the index MCP
                const thumbAcrossFist = Math.abs(landmarks[4].x - landmarks[5].x) < 0.1;
                
                // Thumb not sticking out to the side
                const thumbNotOut = !thumb.thumbOutward;
                
                return allFingersClosed && thumbNotOut;
            }
            
            // T: Fist with thumb poking UP between index and middle fingers
            if (id === 't') {
                const allFingersClosed = !indexExt && !middleExt && !ringExt && !pinkyExt;
                
                const thumbTip = landmarks[4];
                const indexPip = landmarks[6];
                const indexTip = landmarks[8];
                const middlePip = landmarks[10];
                const middleTip = landmarks[12];
                
                // KEY: Thumb tip must be ABOVE the index PIP (poking up from fist)
                const thumbAboveFist = thumbTip.y < indexPip.y - 0.01;
                
                // Thumb should be between index and middle horizontally
                const minX = Math.min(indexPip.x, middlePip.x);
                const maxX = Math.max(indexPip.x, middlePip.x);
                const thumbBetweenFingers = thumbTip.x >= minX - 0.04 && thumbTip.x <= maxX + 0.04;
                
                // Thumb should also be higher than the fingertips (which are curled)
                const thumbHigherThanTips = thumbTip.y < indexTip.y && thumbTip.y < middleTip.y;
                
                return allFingersClosed && thumbAboveFist && thumbBetweenFingers;
            }
            
            // U: Index + middle up together (not spread)
            if (id === 'u') {
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       !fingersSpread(landmarks, 8, 12, 0.04) && // Together
                       !thumb.thumbOutward &&
                       Math.abs(handAngle) < 45;
            }
            
            // V: Index + middle up and spread (peace sign), thumb NOT up between fingers
            if (id === 'v') {
                const thumbTip = landmarks[4];
                const indexMcp = landmarks[5];
                
                // Thumb should be down/tucked, not elevated between fingers
                const thumbNotUp = thumbTip.y > indexMcp.y - 0.02;
                
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       fingersSpread(landmarks, 8, 12, 0.05) &&
                       thumbNotUp &&
                       Math.abs(handAngle) < 45;
            }
            
            // W: Three fingers up and spread
            if (id === 'w') {
                return indexExt && middleExt && ringExt && !pinkyExt &&
                       fingersSpread(landmarks, 8, 12, 0.04);
            }
            
            // X: Index finger bent/hooked (not fully extended, not fully curled)
            if (id === 'x') {
                // Index should be partially extended but bent at the middle joint
                // Tip (8) should be below PIP (6), but PIP should be above MCP (5)
                const indexTip = landmarks[8];
                const indexPip = landmarks[6];
                const indexMcp = landmarks[5];
                
                // The hook: PIP is raised but tip curls down
                const pipRaised = indexPip.y < indexMcp.y;
                const tipBent = indexTip.y > indexPip.y - 0.02;  // Tip not above PIP
                const notFullyCurled = indexPip.y < indexMcp.y + 0.05;  // PIP not fully down
                
                // Alternative: check if index is the only finger "active" and has a bent shape
                const indexActive = landmarks[8].y < landmarks[5].y + 0.1;  // Index doing something
                const indexHooked = indexTip.y > indexPip.y - 0.03 && pipRaised;
                
                return (pipRaised && tipBent && !middleExt && !ringExt && !pinkyExt) ||
                       (indexHooked && !middleExt && !ringExt && !pinkyExt && !indexExt);
            }
            
            // Y: Thumb + pinky out ("hang loose")
            if (id === 'y') {
                return !indexExt && !middleExt && !ringExt && pinkyExt &&
                       thumb.thumbOutward;
            }
            
            // Z: Index up + drawing Z motion (tracked via trail)
            if (id === 'z') {
                const inZPose = indexExt && !middleExt && !ringExt && !pinkyExt;
                if (inZPose && detectZMotion()) {
                    clearTrails(); // Clear after successful detection
                    return true;
                }
                return false;
            }
            
            // ===== NUMBERS =====
            
            // 0: Same as O
            if (id === '0') {
                return fingersTouching(landmarks, 8, 4, 0.07) &&
                       !middleExt && !ringExt && !pinkyExt;
            }
            
            // 1: Index up only
            if (id === '1') {
                return indexExt && !middleExt && !ringExt && !pinkyExt &&
                       !thumb.thumbOutward;
            }
            
            // 2: V sign (index + middle spread), thumb down
            if (id === '2') {
                const thumbTip = landmarks[4];
                const indexMcp = landmarks[5];
                const thumbNotUp = thumbTip.y > indexMcp.y - 0.02;
                
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       fingersSpread(landmarks, 8, 12, 0.05) &&
                       thumbNotUp;
            }
            
            // 3: Thumb + index + middle
            if (id === '3') {
                return indexExt && middleExt && !ringExt && !pinkyExt &&
                       thumb.thumbOutward;
            }
            
            // 4: Four fingers up, thumb tucked
            if (id === '4') {
                return indexExt && middleExt && ringExt && pinkyExt &&
                       thumb.thumbTucked;
            }
            
            // 5: All five spread
            if (id === '5') {
                return indexExt && middleExt && ringExt && pinkyExt &&
                       thumb.thumbOutward;
            }
            
            // 6: Pinky touches thumb, others up
            if (id === '6') {
                return fingersTouching(landmarks, 20, 4, 0.06) &&
                       indexExt && middleExt && ringExt;
            }
            
            // 7: Ring touches thumb, others up
            if (id === '7') {
                return fingersTouching(landmarks, 16, 4, 0.06) &&
                       indexExt && middleExt && pinkyExt;
            }
            
            // 8: Middle touches thumb, others up
            if (id === '8') {
                return fingersTouching(landmarks, 12, 4, 0.06) &&
                       indexExt && ringExt && pinkyExt;
            }
            
            // 9: Index touches thumb, others up
            if (id === '9') {
                return fingersTouching(landmarks, 8, 4, 0.06) &&
                       middleExt && ringExt && pinkyExt;
            }

            // ===== FAMILY SIGNS (Experimental - requires body skeleton) =====

            // Mother: Open hand with thumb on chin
            if (id === 'mother') {
                // Check if we have face landmarks available
                if (currentFaceLandmarks && currentFaceLandmarks.length > 152) {
                    const openHand = isOpen5Hand(landmarks);
                    const thumbOnChin = isThumbNearChin(landmarks, currentFaceLandmarks, 0.12);
                    return openHand && thumbOnChin;
                }
                // Fallback: Just check for open hand if no face detection
                return isOpen5Hand(landmarks);
            }

            // Father: Open hand with thumb on forehead
            if (id === 'father') {
                // Check if we have face landmarks available
                if (currentFaceLandmarks && currentFaceLandmarks.length > 10) {
                    const openHand = isOpen5Hand(landmarks);
                    const thumbOnForehead = isThumbNearForehead(landmarks, currentFaceLandmarks, 0.12);
                    return openHand && thumbOnForehead;
                }
                // Fallback: Just check for open hand if no face detection
                return isOpen5Hand(landmarks);
            }

            // Grandmother: Mother sign (could add motion detection for bounces later)
            if (id === 'grandmother') {
                if (currentFaceLandmarks && currentFaceLandmarks.length > 152) {
                    const openHand = isOpen5Hand(landmarks);
                    const thumbOnChin = isThumbNearChin(landmarks, currentFaceLandmarks, 0.12);
                    return openHand && thumbOnChin;
                }
                return isOpen5Hand(landmarks);
            }

            // Grandfather: Father sign (could add motion detection for bounces later)
            if (id === 'grandfather') {
                if (currentFaceLandmarks && currentFaceLandmarks.length > 10) {
                    const openHand = isOpen5Hand(landmarks);
                    const thumbOnForehead = isThumbNearForehead(landmarks, currentFaceLandmarks, 0.12);
                    return openHand && thumbOnForehead;
                }
                return isOpen5Hand(landmarks);
            }

            return false;
        }
        

        // Draw hand landmarks and connections
        function drawHand(ctx, landmarks, width, height) {
            if (!landmarks) return;
            
            // MediaPipe hand connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],           // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8],           // Index
                [0, 9], [9, 10], [10, 11], [11, 12],      // Middle
                [0, 13], [13, 14], [14, 15], [15, 16],    // Ring
                [0, 17], [17, 18], [18, 19], [19, 20],    // Pinky
                [5, 9], [9, 13], [13, 17]                  // Palm
            ];
            
            // Draw connections (green lines)
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            connections.forEach(([i, j]) => {
                const start = landmarks[i];
                const end = landmarks[j];
                ctx.beginPath();
                ctx.moveTo(start.x * width, start.y * height);
                ctx.lineTo(end.x * width, end.y * height);
                ctx.stroke();
            });
            
            // Draw landmarks (green dots with white center)
            landmarks.forEach((landmark, i) => {
                const x = landmark.x * width;
                const y = landmark.y * height;
                
                // Outer circle (green)
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fillStyle = '#00FF00';
                ctx.fill();
                
                // Inner circle (white)
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
            });
        }

        // ============ BODY SKELETON DRAWING (EXPERIMENTAL) ============

        // Draw a simple body skeleton from pose and face landmarks
        function drawBodySkeleton(ctx, poseLandmarks, faceLandmarks, width, height) {
            if (!poseLandmarks && !faceLandmarks) return;

            ctx.save();

            // Color scheme for body skeleton
            const skeletonColor = '#FF6B6B';  // Coral/red for body
            const faceColor = '#FFB347';       // Orange for face points
            const jointColor = '#FFFFFF';      // White for joint centers

            // Draw pose skeleton (shoulders, arms) if available
            if (poseLandmarks && poseLandmarks.length > 0) {
                ctx.strokeStyle = skeletonColor;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Pose landmark indices (MediaPipe Holistic):
                // 0 = nose, 11 = left shoulder, 12 = right shoulder
                // 13 = left elbow, 14 = right elbow
                // 15 = left wrist, 16 = right wrist

                const leftShoulder = poseLandmarks[11];
                const rightShoulder = poseLandmarks[12];
                const leftElbow = poseLandmarks[13];
                const rightElbow = poseLandmarks[14];
                const leftWrist = poseLandmarks[15];
                const rightWrist = poseLandmarks[16];
                const nose = poseLandmarks[0];

                // Draw shoulder line
                if (leftShoulder && rightShoulder) {
                    ctx.beginPath();
                    ctx.moveTo(leftShoulder.x * width, leftShoulder.y * height);
                    ctx.lineTo(rightShoulder.x * width, rightShoulder.y * height);
                    ctx.stroke();

                    // Draw neck (midpoint of shoulders to nose)
                    if (nose) {
                        const neckX = (leftShoulder.x + rightShoulder.x) / 2 * width;
                        const neckY = (leftShoulder.y + rightShoulder.y) / 2 * height;
                        ctx.beginPath();
                        ctx.moveTo(neckX, neckY);
                        ctx.lineTo(nose.x * width, nose.y * height);
                        ctx.stroke();
                    }
                }

                // Draw left arm
                if (leftShoulder && leftElbow) {
                    ctx.beginPath();
                    ctx.moveTo(leftShoulder.x * width, leftShoulder.y * height);
                    ctx.lineTo(leftElbow.x * width, leftElbow.y * height);
                    ctx.stroke();
                }
                if (leftElbow && leftWrist) {
                    ctx.beginPath();
                    ctx.moveTo(leftElbow.x * width, leftElbow.y * height);
                    ctx.lineTo(leftWrist.x * width, leftWrist.y * height);
                    ctx.stroke();
                }

                // Draw right arm
                if (rightShoulder && rightElbow) {
                    ctx.beginPath();
                    ctx.moveTo(rightShoulder.x * width, rightShoulder.y * height);
                    ctx.lineTo(rightElbow.x * width, rightElbow.y * height);
                    ctx.stroke();
                }
                if (rightElbow && rightWrist) {
                    ctx.beginPath();
                    ctx.moveTo(rightElbow.x * width, rightElbow.y * height);
                    ctx.lineTo(rightWrist.x * width, rightWrist.y * height);
                    ctx.stroke();
                }

                // Draw joints as circles
                const joints = [leftShoulder, rightShoulder, leftElbow, rightElbow, leftWrist, rightWrist];
                joints.forEach(joint => {
                    if (joint && joint.visibility > 0.5) {
                        ctx.beginPath();
                        ctx.arc(joint.x * width, joint.y * height, 8, 0, 2 * Math.PI);
                        ctx.fillStyle = skeletonColor;
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(joint.x * width, joint.y * height, 4, 0, 2 * Math.PI);
                        ctx.fillStyle = jointColor;
                        ctx.fill();
                    }
                });
            }

            // Draw face landmarks (chin, forehead, etc.) if available
            if (faceLandmarks && faceLandmarks.length > 0) {
                // MediaPipe Face Mesh landmark indices:
                // 152 = chin (bottom of face)
                // 10 = forehead (top of face between eyebrows)
                // 234 = left cheek, 454 = right cheek
                // 1 = nose tip

                const chin = faceLandmarks[152];
                const forehead = faceLandmarks[10];
                const noseTip = faceLandmarks[1];
                const leftCheek = faceLandmarks[234];
                const rightCheek = faceLandmarks[454];

                // Draw head outline as an ellipse
                if (forehead && chin) {
                    const centerX = (forehead.x + chin.x) / 2 * width;
                    const centerY = (forehead.y + chin.y) / 2 * height;
                    const radiusY = Math.abs(chin.y - forehead.y) / 2 * height;
                    const radiusX = radiusY * 0.8;

                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                    ctx.strokeStyle = faceColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Draw key face reference points (chin, forehead)
                const facePoints = [
                    { point: chin, label: 'CHIN' },
                    { point: forehead, label: 'FOREHEAD' }
                ];

                facePoints.forEach(({ point, label }) => {
                    if (point) {
                        const x = point.x * width;
                        const y = point.y * height;

                        // Outer circle
                        ctx.beginPath();
                        ctx.arc(x, y, 10, 0, 2 * Math.PI);
                        ctx.fillStyle = faceColor;
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Inner circle
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = jointColor;
                        ctx.fill();

                        // Label
                        ctx.font = 'bold 10px DM Sans, sans-serif';
                        ctx.fillStyle = faceColor;
                        ctx.textAlign = 'center';
                        ctx.fillText(label, x, y - 15);
                    }
                });

                // Store face landmarks globally for sign detection
                currentFaceLandmarks = faceLandmarks;
            }

            ctx.restore();
        }

        // Check if thumb is near chin (for Mother sign)
        function isThumbNearChin(handLandmarks, faceLandmarks, threshold = 0.08) {
            if (!handLandmarks || !faceLandmarks || faceLandmarks.length < 153) return false;

            const thumbTip = handLandmarks[4];
            const chin = faceLandmarks[152];

            if (!thumbTip || !chin) return false;

            const dx = thumbTip.x - chin.x;
            const dy = thumbTip.y - chin.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance < threshold;
        }

        // Check if thumb is near forehead (for Father sign)
        function isThumbNearForehead(handLandmarks, faceLandmarks, threshold = 0.08) {
            if (!handLandmarks || !faceLandmarks || faceLandmarks.length < 11) return false;

            const thumbTip = handLandmarks[4];
            const forehead = faceLandmarks[10];

            if (!thumbTip || !forehead) return false;

            const dx = thumbTip.x - forehead.x;
            const dy = thumbTip.y - forehead.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance < threshold;
        }

        // Check if hand is in open-5 position (spread fingers)
        function isOpen5Hand(landmarks) {
            if (!landmarks) return false;

            const indexUp = landmarks[8].y < landmarks[6].y - 0.02;
            const middleUp = landmarks[12].y < landmarks[10].y - 0.02;
            const ringUp = landmarks[16].y < landmarks[14].y - 0.02;
            const pinkyUp = landmarks[20].y < landmarks[18].y - 0.02;

            // Fingers should be spread
            const spread1 = landmarkDist(landmarks, 8, 12) > 0.03;
            const spread2 = landmarkDist(landmarks, 12, 16) > 0.025;
            const spread3 = landmarkDist(landmarks, 16, 20) > 0.025;

            return indexUp && middleUp && ringUp && pinkyUp && spread1 && spread2 && spread3;
        }

        // Camera handling - Test Mode
        function onTestResults(results) {
            const canvas = document.getElementById('testCanvas');
            const video = document.getElementById('testVideo');
            const ctx = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw body skeleton if holistic data is available
            if (results.poseLandmarks || results.faceLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                currentFaceLandmarks = results.faceLandmarks;
                drawBodySkeleton(ctx, results.poseLandmarks, results.faceLandmarks, canvas.width, canvas.height);
            }

            // Get hand landmarks - works with both Hands and Holistic
            const handLandmarks = results.multiHandLandmarks?.[0] ||
                                  results.leftHandLandmarks ||
                                  results.rightHandLandmarks;

            // Draw hand skeleton and trails if detected
            if (handLandmarks) {
                drawHand(ctx, handLandmarks, canvas.width, canvas.height);

                // Check poses for trail tracking
                const indexExt = handLandmarks[8].y < handLandmarks[6].y - 0.02;
                const middleExt = handLandmarks[12].y < handLandmarks[10].y - 0.02;
                const ringExt = handLandmarks[16].y < handLandmarks[14].y - 0.02;
                const pinkyExt = handLandmarks[20].y < handLandmarks[18].y - 0.02;

                const isJPose = !indexExt && !middleExt && !ringExt && pinkyExt;
                const isZPose = indexExt && !middleExt && !ringExt && !pinkyExt;

                updateTrails(handLandmarks, isJPose, isZPose);
                drawTrails(ctx, canvas.width, canvas.height);
            }

            if (handLandmarks && testSign) {
                if (detectSign(handLandmarks, testSign)) {
                    const now = Date.now();
                    if (now - lastDetectionTime > 2000) {
                        lastDetectionTime = now;
                        testScore++;
                        testTotal++;
                        document.getElementById('testCorrect').textContent = testScore;
                        document.getElementById('testTotal').textContent = testTotal;
                        document.getElementById('testFeedback').textContent = '‚úì Correct!';
                        document.getElementById('testFeedback').className = 'feedback-banner success';
                        setTimeout(generateTestQuestion, 1500);
                    }
                }
            }
        }
        
        // Camera handling - Practice Mode
        function onPracticeResults(results) {
            const canvas = document.getElementById('practiceCanvas');
            const video = document.getElementById('practiceVideo');
            const ctx = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw body skeleton if holistic data is available
            if (results.poseLandmarks || results.faceLandmarks) {
                currentPoseLandmarks = results.poseLandmarks;
                currentFaceLandmarks = results.faceLandmarks;
                drawBodySkeleton(ctx, results.poseLandmarks, results.faceLandmarks, canvas.width, canvas.height);
            }

            // Get hand landmarks - works with both Hands and Holistic
            const handLandmarks = results.multiHandLandmarks?.[0] ||
                                  results.leftHandLandmarks ||
                                  results.rightHandLandmarks;

            // Draw hand skeleton and trails if detected
            if (handLandmarks) {
                drawHand(ctx, handLandmarks, canvas.width, canvas.height);

                // Check poses for trail tracking
                const indexExt = handLandmarks[8].y < handLandmarks[6].y - 0.02;
                const middleExt = handLandmarks[12].y < handLandmarks[10].y - 0.02;
                const ringExt = handLandmarks[16].y < handLandmarks[14].y - 0.02;
                const pinkyExt = handLandmarks[20].y < handLandmarks[18].y - 0.02;

                const isJPose = !indexExt && !middleExt && !ringExt && pinkyExt;
                const isZPose = indexExt && !middleExt && !ringExt && !pinkyExt;

                updateTrails(handLandmarks, isJPose, isZPose);
                drawTrails(ctx, canvas.width, canvas.height);
            }

            if (handLandmarks && practiceSign) {
                if (detectSign(handLandmarks, practiceSign)) {
                    const now = Date.now();
                    if (now - lastDetectionTime > 2000) {
                        lastDetectionTime = now;
                        practiceScore++;
                        practiceAttempts++;
                        document.getElementById('practiceCorrect').textContent = practiceScore;
                        document.getElementById('practiceAttempts').textContent = practiceAttempts;
                        document.getElementById('practiceFeedback').textContent = `‚úì Perfect ${practiceSign.name}!`;
                        document.getElementById('practiceFeedback').className = 'feedback-banner success';
                        setTimeout(() => {
                            if (practiceSign) {
                                document.getElementById('practiceFeedback').textContent = `Practice: ${practiceSign.name}`;
                                document.getElementById('practiceFeedback').className = 'feedback-banner prompt';
                            }
                        }, 1500);
                    }
                }
            }
        }
        
        // Start/Stop camera functions
        async function startCamera(mode) {
            const video = document.getElementById(mode + 'Video');
            const canvas = document.getElementById(mode + 'Canvas');
            const btn = document.getElementById(mode + 'CameraBtn');
            const placeholder = document.getElementById(mode + 'Placeholder');
            
            // Update UI to show loading
            btn.textContent = 'Loading...';
            btn.disabled = true;
            
            try {
                console.log('Starting camera for mode:', mode);

                // Get camera stream first (reduced resolution for performance)
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: VIDEO_WIDTH },
                        height: { ideal: VIDEO_HEIGHT }
                    }
                });
                video.srcObject = stream;

                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                console.log('Video ready:', video.videoWidth, 'x', video.videoHeight);

                // Initialize MediaPipe - use Holistic for body skeleton or Hands for hand-only
                let mediapipeInstance;

                if (useHolisticMode) {
                    console.log('Initializing MediaPipe Holistic (lite mode for performance)...');
                    mediapipeInstance = new Holistic({
                        locateFile: (file) => {
                            console.log('Loading MediaPipe Holistic file:', file);
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
                        }
                    });

                    mediapipeInstance.setOptions({
                        modelComplexity: 0, // Lite mode - much faster
                        smoothLandmarks: true,
                        enableSegmentation: false,
                        smoothSegmentation: false,
                        refineFaceLandmarks: false, // Disabled for performance
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    mediapipeInstance.onResults((results) => {
                        if (mode === 'test') {
                            onTestResults(results);
                        } else {
                            onPracticeResults(results);
                        }
                    });

                    await mediapipeInstance.initialize();
                    console.log('MediaPipe Holistic initialized (body skeleton enabled)');
                    holistic = mediapipeInstance;
                } else {
                    console.log('Initializing MediaPipe Hands (hand-only mode)...');
                    mediapipeInstance = new Hands({
                        locateFile: (file) => {
                            console.log('Loading MediaPipe file:', file);
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                        }
                    });

                    mediapipeInstance.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    mediapipeInstance.onResults((results) => {
                        if (mode === 'test') {
                            onTestResults(results);
                        } else {
                            onPracticeResults(results);
                        }
                    });

                    await mediapipeInstance.initialize();
                    console.log('MediaPipe Hands initialized');
                    hands = mediapipeInstance;
                }
                
                // Set up the processing loop with frame skipping for performance
                const processFrame = async () => {
                    if ((mode === 'test' && testCameraActive) || (mode === 'practice' && practiceCameraActive)) {
                        if (video.readyState >= 2) {
                            // Frame skipping for better performance
                            frameSkipCount++;
                            if (frameSkipCount >= FRAME_SKIP) {
                                frameSkipCount = 0;
                                // Use holistic or hands based on mode
                                const instance = useHolisticMode ? holistic : hands;
                                if (instance) {
                                    await instance.send({ image: video });
                                }
                            }
                        }
                        requestAnimationFrame(processFrame);
                    }
                };
                
                // Update state and UI
                if (mode === 'test') {
                    testCameraActive = true;
                } else {
                    practiceCameraActive = true;
                }
                
                placeholder.style.display = 'none';
                btn.textContent = 'Stop Camera';
                btn.disabled = false;
                btn.classList.add('active');
                
                // Start processing frames
                processFrame();
                
                console.log('Camera started successfully');
                
            } catch (e) {
                console.error('Camera error:', e);
                btn.textContent = 'Start Camera';
                btn.disabled = false;
                alert('Camera error: ' + e.message);
            }
        }
        
        function stopCamera(mode) {
            console.log('Stopping camera for mode:', mode);
            
            const video = document.getElementById(mode + 'Video');
            const btn = document.getElementById(mode + 'CameraBtn');
            const placeholder = document.getElementById(mode + 'Placeholder');
            
            // Stop the camera active flag first to stop the processing loop
            if (mode === 'test') {
                testCameraActive = false;
            } else {
                practiceCameraActive = false;
            }
            
            // Stop video stream
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Clear the canvas
            const canvas = document.getElementById(mode + 'Canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update UI
            placeholder.style.display = 'flex';
            btn.textContent = 'Start Camera';
            btn.classList.remove('active');
        }
        
        document.getElementById('testCameraBtn').addEventListener('click', () => {
            if (testCameraActive) {
                stopCamera('test');
            } else {
                startCamera('test');
            }
        });
        
        document.getElementById('practiceCameraBtn').addEventListener('click', () => {
            if (practiceCameraActive) {
                stopCamera('practice');
            } else {
                startCamera('practice');
            }
        });

        // Body Skeleton Toggle Event Listeners
        function updateSkeletonMode(enabled) {
            useHolisticMode = enabled;
            // Sync both toggles
            const testToggle = document.getElementById('testSkeletonToggle');
            const practiceToggle = document.getElementById('practiceSkeletonToggle');
            if (testToggle) testToggle.checked = enabled;
            if (practiceToggle) practiceToggle.checked = enabled;

            // If camera is active, automatically restart it with new mode
            if (testCameraActive) {
                console.log('Restarting test camera with new mode...');
                stopCamera('test');
                setTimeout(() => startCamera('test'), 300);
            }
            if (practiceCameraActive) {
                console.log('Restarting practice camera with new mode...');
                stopCamera('practice');
                setTimeout(() => startCamera('practice'), 300);
            }
        }

        document.getElementById('testSkeletonToggle')?.addEventListener('change', (e) => {
            updateSkeletonMode(e.target.checked);
        });

        document.getElementById('practiceSkeletonToggle')?.addEventListener('change', (e) => {
            updateSkeletonMode(e.target.checked);
        });


        // Detect open palm gesture (for adding space)
        function detectOpenPalm(landmarks) {
            if (!landmarks) return false;
            
            // All five digits should be extended and spread
            const thumbOut = landmarkDist(landmarks, 4, 2) > 0.08;
            const indexUp = landmarks[8].y < landmarks[6].y - 0.02;
            const middleUp = landmarks[12].y < landmarks[10].y - 0.02;
            const ringUp = landmarks[16].y < landmarks[14].y - 0.02;
            const pinkyUp = landmarks[20].y < landmarks[18].y - 0.02;
            
            // Fingers should be spread apart
            const spread1 = landmarkDist(landmarks, 8, 12) > 0.04;
            const spread2 = landmarkDist(landmarks, 12, 16) > 0.03;
            const spread3 = landmarkDist(landmarks, 16, 20) > 0.03;
            
            return thumbOut && indexUp && middleUp && ringUp && pinkyUp && 
                   spread1 && spread2 && spread3;
        }

        // ============ TRANSLATE MODE ============
        
        let translatedText = '';
        let currentDetectedSign = null;
        let signStartTime = 0;
        let lastConfirmedSign = null;
        let confirmationThreshold = 2000; // 2 seconds to confirm a letter
        let cooldownTime = 800; // 0.8s cooldown after confirming
        let lastConfirmTime = 0;
        let consecutiveDetections = 0;
        let requiredConsecutive = 8; // Need 8 consistent detections
        let graceFrames = 0; // Allow brief detection gaps
        let maxGraceFrames = 5; // Up to 5 frames of "no detection" allowed
        
        // Build the quick reference grid for translate mode
        function buildTranslateReference() {
            const grid = document.getElementById('translateReference');
            if (!grid) return;
            
            SIGNS.filter(s => s.type === 'letter').forEach(sign => {
                const tile = document.createElement('div');
                tile.className = 'sign-tile';
                tile.innerHTML = `
                    <img src="${ASL_IMAGES[sign.id]}" alt="${sign.name}">
                    <span class="sign-tile-label">${sign.name}</span>
                `;
                grid.appendChild(tile);
            });
        }
        
        // Update the translation display
        function updateTranslationDisplay() {
            const output = document.getElementById('translationOutput');
            if (translatedText === '') {
                output.innerHTML = '<span class="placeholder-text">Start signing to see translation...</span>';
            } else {
                output.innerHTML = translatedText + '<span class="cursor"></span>';
            }
        }
        
        // Add a letter to the translation
        function addLetterToTranslation(letter) {
            translatedText += letter;
            updateTranslationDisplay();
            
            // Visual feedback on the overlay
            const overlay = document.getElementById('currentSignOverlay');
            overlay.classList.add('letter-confirmed');
            setTimeout(() => overlay.classList.remove('letter-confirmed'), 300);
        }
        
        // Process translate mode results
        function onTranslateResults(results) {
            const canvas = document.getElementById('translateCanvas');
            const video = document.getElementById('translateVideo');
            const ctx = canvas.getContext('2d');
            const overlay = document.getElementById('currentSignOverlay');
            const ring = document.getElementById('confirmRing');
            const ringProgress = ring.querySelector('.confirm-ring-progress');
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const now = Date.now();
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw hand skeleton
                drawHand(ctx, landmarks, canvas.width, canvas.height);
                
                // Check poses for trail tracking
                const indexExt = landmarks[8].y < landmarks[6].y - 0.02;
                const middleExt = landmarks[12].y < landmarks[10].y - 0.02;
                const ringExt = landmarks[16].y < landmarks[14].y - 0.02;
                const pinkyExt = landmarks[20].y < landmarks[18].y - 0.02;
                
                const isJPose = !indexExt && !middleExt && !ringExt && pinkyExt;
                const isZPose = indexExt && !middleExt && !ringExt && !pinkyExt;
                
                updateTrails(landmarks, isJPose, isZPose);
                drawTrails(ctx, canvas.width, canvas.height);
                
                // Check cooldown
                if (now - lastConfirmTime < cooldownTime) {
                    return;
                }
                
                // First check for open palm (space gesture)
                if (detectOpenPalm(landmarks)) {
                    overlay.textContent = '‚ê£';
                    overlay.classList.add('active');
                    ring.classList.add('active');
                    
                    if (currentDetectedSign && currentDetectedSign.id === 'space') {
                        consecutiveDetections++;
                        const elapsed = now - signStartTime;
                        const progress = Math.min(elapsed / confirmationThreshold, 1);
                        const circumference = 163.36;
                        ringProgress.style.strokeDashoffset = circumference * (1 - progress);
                        
                        if (elapsed >= confirmationThreshold && consecutiveDetections >= requiredConsecutive) {
                            if (lastConfirmedSign !== 'space') {
                                translatedText += ' ';
                                updateTranslationDisplay();
                                lastConfirmedSign = 'space';
                                lastConfirmTime = now;
                                ringProgress.style.strokeDashoffset = circumference;
                            }
                        }
                    } else {
                        currentDetectedSign = {id: 'space', name: ' '};
                        signStartTime = now;
                        consecutiveDetections = 1;
                        lastConfirmedSign = null;
                    }
                    return;
                }
                
                // Try to detect which sign is being made
                let detectedSign = null;
                for (const sign of SIGNS) {
                    if (sign.type === 'letter' && detectSign(landmarks, sign)) {
                        detectedSign = sign;
                        break;
                    }
                }
                
                if (detectedSign) {
                    // Show current detection
                    overlay.textContent = detectedSign.name;
                    overlay.classList.add('active');
                    ring.classList.add('active');
                    graceFrames = 0; // Reset grace counter
                    
                    // Check if same sign as before (or no previous sign)
                    if (!currentDetectedSign || currentDetectedSign.id === detectedSign.id) {
                        if (!currentDetectedSign) {
                            currentDetectedSign = detectedSign;
                            signStartTime = now;
                            consecutiveDetections = 0;
                        }
                        consecutiveDetections++;
                        
                        // Calculate progress based on time
                        const elapsed = now - signStartTime;
                        const progress = Math.min(elapsed / confirmationThreshold, 1);
                        
                        // Update ring progress
                        const circumference = 163.36;
                        const offset = circumference * (1 - progress);
                        ringProgress.style.strokeDashoffset = offset;
                        
                        // Confirm if held long enough
                        if (elapsed >= confirmationThreshold && consecutiveDetections >= requiredConsecutive) {
                            if (lastConfirmedSign !== detectedSign.id) {
                                addLetterToTranslation(detectedSign.name);
                                lastConfirmedSign = detectedSign.id;
                                lastConfirmTime = now;
                                ringProgress.style.strokeDashoffset = circumference;
                                // Reset for next letter
                                currentDetectedSign = null;
                                consecutiveDetections = 0;
                            }
                        }
                    } else {
                        // Different sign detected - reset
                        currentDetectedSign = detectedSign;
                        signStartTime = now;
                        consecutiveDetections = 1;
                        lastConfirmedSign = null;
                        ringProgress.style.strokeDashoffset = 163.36;
                    }
                } else {
                    // No sign detected - use grace period before resetting
                    graceFrames++;
                    if (graceFrames > maxGraceFrames) {
                        // Grace period exceeded, reset
                        overlay.classList.remove('active');
                        ring.classList.remove('active');
                        currentDetectedSign = null;
                        consecutiveDetections = 0;
                        ringProgress.style.strokeDashoffset = 163.36;
                    }
                    // Otherwise keep the current state (grace period active)
                }
            } else {
                // No hand detected
                overlay.classList.remove('active');
                ring.classList.remove('active');
                currentDetectedSign = null;
                consecutiveDetections = 0;
                ringProgress.style.strokeDashoffset = 163.36;
            }
        }
        
        // Translate camera controls (disabled - mode removed)
        if (document.getElementById('translateCameraBtn')) {
            document.getElementById('translateCameraBtn').addEventListener('click', async () => {
            if (translateCameraActive) {
                stopTranslateCamera();
            } else {
                await startTranslateCamera();
            }
        });
        }
        
        async function startTranslateCamera() {
            const video = document.getElementById('translateVideo');
            const btn = document.getElementById('translateCameraBtn');
            const placeholder = document.getElementById('translatePlaceholder');
            
            btn.textContent = 'Loading...';
            btn.disabled = true;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });
                
                const handsInstance = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });
                
                handsInstance.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });
                
                handsInstance.onResults(onTranslateResults);
                await handsInstance.initialize();
                
                hands = handsInstance;
                translateCameraActive = true;
                
                const processFrame = async () => {
                    if (translateCameraActive) {
                        if (video.readyState >= 2) {
                            await hands.send({ image: video });
                        }
                        requestAnimationFrame(processFrame);
                    }
                };
                
                placeholder.style.display = 'none';
                btn.textContent = 'Stop Translating';
                btn.disabled = false;
                btn.classList.add('active');
                
                processFrame();
                
            } catch (e) {
                console.error('Camera error:', e);
                btn.textContent = 'Start Translating';
                btn.disabled = false;
                alert('Camera error: ' + e.message);
            }
        }
        
        function stopTranslateCamera() {
            const video = document.getElementById('translateVideo');
            const btn = document.getElementById('translateCameraBtn');
            const placeholder = document.getElementById('translatePlaceholder');
            
            translateCameraActive = false;
            
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            const canvas = document.getElementById('translateCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('currentSignOverlay').classList.remove('active');
            document.getElementById('confirmRing').classList.remove('active');
            
            placeholder.style.display = 'flex';
            btn.textContent = 'Start Translating';
            btn.classList.remove('active');
        }
        
        // Translation controls (disabled - mode removed)
        if (document.getElementById('addSpace')) {
            document.getElementById('addSpace').addEventListener('click', () => {
                translatedText += ' ';
                updateTranslationDisplay();
            });
        }
        
        if (document.getElementById('backspace')) {
            document.getElementById('backspace').addEventListener('click', () => {
                translatedText = translatedText.slice(0, -1);
                updateTranslationDisplay();
            });
        }
        
        if (document.getElementById('clearTranslation')) {
            document.getElementById('clearTranslation').addEventListener('click', () => {
                translatedText = '';
                updateTranslationDisplay();
            });
        }
        
        if (document.getElementById('copyTranslation')) {
            document.getElementById('copyTranslation').addEventListener('click', async () => {
                if (translatedText) {
                    try {
                        await navigator.clipboard.writeText(translatedText);
                        const btn = document.getElementById('copyTranslation');
                        const originalText = btn.textContent;
                        btn.textContent = 'Copied!';
                        setTimeout(() => btn.textContent = originalText, 1500);
                    } catch (e) {
                        alert('Could not copy: ' + e.message);
                    }
                }
            });
        }
        
        // Initialize translate reference grid (disabled - mode removed)
        // buildTranslateReference();

        // Start app
        init();
    </script>
</body>
</html>
